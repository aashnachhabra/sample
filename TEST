existing backend
package com.optum.ideate.controller; import com.amazonaws.util.IOUtils; import com.mongodb.client.result.UpdateResult; import com.optum.ideate.api.request.v1.DropdownOption; import com.optum.ideate.aspose.Constants; import com.optum.ideate.constants.SessionConstants; import com.optum.ideate.model.request.CloneMaximumManagementRequestList; import com.optum.ideate.model.request.ParentMaximumRequest; import com.optum.ideate.model.request.MaximumChangedSearchRequest; import com.optum.ideate.model.response.MaximumChangedSearchResponse; import com.optum.ideate.model.response.MaximumMgmtDDMapResponse; import com.optum.ideate.model.response.PlanAssignmentRequest; import com.optum.ideate.mongodb.domain.MasterBenefitCategoryCollection; import com.optum.ideate.mongodb.domain.MaxMgmtProcessLog; import com.optum.ideate.mongodb.domain.MaximumManagementCollection; import com.optum.ideate.mongodb.domain.PlIFPDropdowns; import com.optum.ideate.mongodb.repo.MaxMgmtProcessLogRepository; import com.optum.ideate.mongodb.domain.PortfolioEditorDropDownCollection; import com.optum.ideate.mongodb.repo.MaximumManagementCollectionRepository; import com.optum.ideate.mongodb.repo.PlIFPDropdownsRepository; import com.optum.ideate.mongodb.repo.PortfolioEditorDropDownRepository; import com.optum.ideate.service.MaximumManagementService; import com.optum.ideate.service.ProductManagmentService; import com.optum.ideate.util.MaximumTrackPlanUpdates; import com.optum.ideate.utils.ErrorUtil; import jakarta.servlet.http.HttpServletResponse; import lombok.SneakyThrows; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.lang3.ObjectUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.data.mongodb.core.query.Criteria; import org.springframework.data.mongodb.core.query.Query; import org.springframework.data.mongodb.core.query.Update; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import org.springframework.web.bind.support.DefaultSessionAttributeStore; import org.springframework.web.context.request.WebRequest; import org.springframework.web.servlet.ModelAndView; import org.apache.commons.lang3.StringUtils; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpSession; import java.io.ByteArrayInputStream; import java.io.IOException; import java.util.*; import java.util.stream.Collectors; @Controller public class MaximumManagementController { @Autowired @Qualifier("mongoTemplate") private MongoTemplate mongoTemplate; @Autowired private PortfolioEditorDropDownRepository portfolioEditorDropDownRepository; @Autowired MaximumManagementCollectionRepository repo; @Autowired private ProductManagmentService productManagmentService; @Autowired MaximumManagementCollectionRepository maximumRepo; @Autowired MaximumManagementService maximumManagementService; @Autowired PlIFPDropdownsRepository plIFPDropdownsRepository; @Autowired MaxMgmtProcessLogRepository maxMgmtProcessLogRepository; private final static Logger logger = LoggerFactory.getLogger(MaximumManagementController.class); @GetMapping("/maxManagement") public ModelAndView maximumManagement(ModelAndView modelAndView, HttpServletRequest request) { try { modelAndView.setViewName("MaximumManagement"); MaximumMgmtDDMapResponse maximumMgmtDDMapResponse; MaximumMgmtDDMapResponse maximumMgmtDDMapResponseForIEX; HttpSession session = request.getSession(); maximumMgmtDDMapResponse = maximumManagementService.getMaximumMgmtDropDownsMap(); maximumMgmtDDMapResponseForIEX = maximumManagementService.getMaximumMgmtDropDownsForIEXOrg(); maximumMgmtDDMapResponse.getStandardMap().clear(); maximumMgmtDDMapResponse.getStandardMap().putAll(maximumMgmtDDMapResponseForIEX.getStandardMap()); session.setAttribute("maximumMngDDMap", maximumMgmtDDMapResponse); modelAndView.addObject("maximumDD", maximumMgmtDDMapResponse); List<MaximumManagementCollection> allMaxData = maximumManagementService.getAllMaxManagementData(); modelAndView.addObject("maxManagementSearchResponse", allMaxData); modelAndView.addObject("maxManagementSearchRequest", null); session.setAttribute("maxManagementSearchRequest", null); // Populate all dropdowns same as in maxManagementSearch List<MasterBenefitCategoryCollection> benefitCategoryList = productManagmentService.getMasterBenefitCategoryCollection(); List<String> benefitCategoryNames = new ArrayList<>(); if (CollectionUtils.isNotEmpty(benefitCategoryList)) { benefitCategoryList.stream().forEach(bcl -> benefitCategoryNames.add(bcl.getBenefitCategoryValue())); } benefitCategoryNames.sort(Comparator.naturalOrder()); modelAndView.addObject(Constants.BEN_CAT_NAMES, benefitCategoryNames); // Use default values since no specific COC is selected yet List<String> limitTypes = Constants.limitType; List<String> frequencyTypes = Constants.frequencyType; List<String> appliesTo = Constants.appliesTo; limitTypes.remove(" "); modelAndView.addObject(Constants.LIMIT_TYPES, limitTypes); frequencyTypes.remove(" "); modelAndView.addObject(Constants.FREQUENCY_TYPES, frequencyTypes); appliesTo.remove(" "); appliesTo.sort(Comparator.naturalOrder()); modelAndView.addObject(Constants.APPLIES_TO, appliesTo); List<String> crossApplies = Constants.crossApplies; crossApplies.remove(" "); modelAndView.addObject(Constants.CROSS_APPLIES, crossApplies); List<String> visible = Constants.visible; visible.remove(" "); modelAndView.addObject(Constants.VISIBLE, visible); List<String> subCategory = Constants.subCategory; modelAndView.addObject(Constants.SUBCATEGORY, subCategory); return modelAndView; } catch (Exception exception) { return ErrorUtil.validateErrorMessage(exception); } } @GetMapping("/maxManagement/all-product-family") @ResponseBody public List<String> getAllPortfolioManagementProductFamily() { MaximumMgmtDDMapResponse maximumMgmtDDMapResponseForIEX; maximumMgmtDDMapResponseForIEX = maximumManagementService.getMaximumMgmtDropDownsForIEXOrg(); return maximumMgmtDDMapResponseForIEX.getStandardMap().values().stream() .sorted() .collect(Collectors.toList()); } @PostMapping("/maxManagementSearch") public ModelAndView getMaximumSearchData(@ModelAttribute PlanAssignmentRequest planAssignmentRequest, WebRequest request) { ModelAndView modelAndView = new ModelAndView(); Integer isCurrent = 1; DefaultSessionAttributeStore session = new DefaultSessionAttributeStore(); if (session.retrieveAttribute(request, "maxManagementSearchRequest") == null) { session.storeAttribute(request, "maxManagementSearchRequest", planAssignmentRequest); } MaximumMgmtDDMapResponse maximumMgmtDDMapResponse; if (session.retrieveAttribute(request, "maximumMngDDMap") == null) { maximumMgmtDDMapResponse = maximumManagementService.getMaximumMgmtDropDownsMap(); session.storeAttribute(request, "maximumMngDDMap", maximumMgmtDDMapResponse); } else { maximumMgmtDDMapResponse = (MaximumMgmtDDMapResponse) session.retrieveAttribute(request, "maximumMngDDMap"); } PlIFPDropdowns plIFPDropdowns = null; String cocSeries = planAssignmentRequest.getCoc(); TreeMap<String, String> productFamilyTreeMap = new TreeMap<>(); if (StringUtils.isNotEmpty(cocSeries)) { if (cocSeries.contains(",")) { String[] arrOfStr = cocSeries.split(","); for (String coc : arrOfStr) { plIFPDropdowns = plIFPDropdownsRepository.findByCocSeriesAndIsCurrent(Integer.parseInt(coc.trim()), isCurrent); if (ObjectUtils.isNotEmpty(plIFPDropdowns) && ObjectUtils.isNotEmpty(plIFPDropdowns.getProductFamily()) && ObjectUtils.isNotEmpty(maximumMgmtDDMapResponse)) { plIFPDropdowns.getProductFamily() .stream() .filter(e -> e.getIsCurrent() == 1) .forEach(item -> productFamilyTreeMap.put(item.getName(), item.getName())); } } } else { plIFPDropdowns = plIFPDropdownsRepository.findByCocSeriesAndIsCurrent(Integer.parseInt(cocSeries.trim()), isCurrent); if (ObjectUtils.isNotEmpty(plIFPDropdowns) && ObjectUtils.isNotEmpty(plIFPDropdowns.getProductFamily()) && ObjectUtils.isNotEmpty(maximumMgmtDDMapResponse)) { plIFPDropdowns.getProductFamily() .stream() .filter(e -> e.getIsCurrent() == 1) .forEach(item -> productFamilyTreeMap.put(item.getName(), item.getName())); } } maximumMgmtDDMapResponse.setStandardMap(productFamilyTreeMap); } else { PortfolioEditorDropDownCollection portfolioEditorDropDownCollection = portfolioEditorDropDownRepository.findByPageName("Portfolio Editor"); portfolioEditorDropDownCollection.getProductFamily() .stream() .map(DropdownOption::getName) .forEach(item -> productFamilyTreeMap.put(item, item)); maximumMgmtDDMapResponse.setStandardMap(productFamilyTreeMap); } modelAndView.addObject("maximumDD", maximumMgmtDDMapResponse); List<MaximumManagementCollection> maximumList = maximumManagementService.getMaxSearchData(planAssignmentRequest); List<MaximumManagementCollection> filteredDeletedMaximumList = maximumList.stream().filter (e -> e.getStatus().equals(Constants.currentDeleted)).collect(Collectors.toList()); List<MaximumManagementCollection> filteredMaximumList = maximumList.stream().filter (e -> e.getStatus().equals(Constants.active)).collect(Collectors.toList()); modelAndView.addObject("enabledCascade", false); if (!filteredMaximumList.isEmpty()) { filteredMaximumList.forEach(request1 -> { if (request1.isBulkCascadeRequired()) { modelAndView.addObject("enabledCascade", true); } }); } List<MaximumManagementCollection> filteredCurrentDeletedList = maximumList.stream().filter (e -> e.getStatus().equals(Constants.currentDeleted)).collect(Collectors.toList()); if (!filteredCurrentDeletedList.isEmpty()) { filteredCurrentDeletedList.forEach(request1 -> { updateStatus(request1.getMaxId().intValue(), Constants.deleted); modelAndView.addObject("enabledCascade", true); }); } modelAndView.setViewName("MaximumManagement"); modelAndView.addObject("maxManagementSearchRequest", planAssignmentRequest); modelAndView.addObject("maxManagementSearchResponse", filteredMaximumList); List<MasterBenefitCategoryCollection> benefitCategoryList = productManagmentService.getMasterBenefitCategoryCollection(); List<String> benefitCategoryNames = new ArrayList<>(); if (CollectionUtils.isNotEmpty(benefitCategoryList)) { benefitCategoryList.stream().forEach(bcl -> benefitCategoryNames.add(bcl.getBenefitCategoryValue())); } benefitCategoryNames.sort(Comparator.naturalOrder()); modelAndView.addObject(Constants.BEN_CAT_NAMES, benefitCategoryNames); List<String> limitTypes = Constants.limitType; List<String> frequencyTypes = Constants.frequencyType; List<String> appliesTo = Constants.appliesTo; if (plIFPDropdowns != null) { limitTypes = plIFPDropdowns.getLimitType() != null ? plIFPDropdowns.getLimitType() .stream().filter(e -> e.getIsCurrent() == 1) .map(DropdownOption::getName) .collect(Collectors.toList()) : Constants.limitType; frequencyTypes = plIFPDropdowns.getFrequencyType() != null ? plIFPDropdowns.getFrequencyType() .stream().filter(e -> e.getIsCurrent() == 1) .map(DropdownOption::getName) .collect(Collectors.toList()) : Constants.frequencyType; appliesTo = plIFPDropdowns.getAppliesTo() != null ? plIFPDropdowns.getAppliesTo() .stream().filter(e -> e.getIsCurrent() == 1) .map(DropdownOption::getName) .collect(Collectors.toList()) : Constants.appliesTo; } limitTypes.remove(" "); modelAndView.addObject(Constants.LIMIT_TYPES, limitTypes); frequencyTypes.remove(" "); modelAndView.addObject(Constants.FREQUENCY_TYPES, frequencyTypes); appliesTo.remove(" "); appliesTo.sort(Comparator.naturalOrder()); modelAndView.addObject(Constants.APPLIES_TO, appliesTo); List<String> crossApplies = Constants.crossApplies; crossApplies.remove(" "); modelAndView.addObject(Constants.CROSS_APPLIES, crossApplies); List<String> visible = Constants.visible; visible.remove(" "); modelAndView.addObject(Constants.VISIBLE, visible); List<String> subCategory = Constants.subCategory; modelAndView.addObject(Constants.SUBCATEGORY, subCategory); return modelAndView; } @PostMapping("/saveNewMaximum") @ResponseBody @SneakyThrows public ResponseEntity<Object> saveNewMaximum(HttpServletRequest request, @RequestBody MaximumManagementCollection managementCollection) { HttpSession session = request.getSession(); String currentUser = (String) session.getAttribute(SessionConstants.USER_NAME); MaximumTrackPlanUpdates.setCurrentUser(currentUser); try { MaximumManagementCollection max = maximumRepo.findTopByOrderByMaxIdDesc(); Long maxIdVal = max.getMaxId(); logger.info("MaximumManagementController :: saveNewMaximum() maxIdVal : " + maxIdVal); logger.info("MaximumManagementController :: saveNewMaximum() subCategory received: " + managementCollection.getSubCategory()); if (managementCollection.getMaxId() == null) { PlanAssignmentRequest planAssignmentRequest = toPlanAssignmentRequest(managementCollection); List<MaximumManagementCollection> maximumList = maximumManagementService.getMaxSearchData(planAssignmentRequest); List<MaximumManagementCollection> identicalRecords = maximumList.stream() .filter(e -> e.getStatus().equals(Constants.active) && areMaximumsIdentical(e, managementCollection)) .collect(Collectors.toList()); if (!identicalRecords.isEmpty()) { logger.warn("Duplicate maximum found - rejecting save. Matching records: " + identicalRecords.size()); return ResponseEntity.status(HttpStatus.CREATED).body(Collections.singletonMap("newMaximums", 0)); } logger.info("No duplicate found - saving new maximum"); managementCollection.setMaxId(maxIdVal + 1); managementCollection.setStatus(Constants.active); managementCollection.setBulkCascadeRequired(true); maximumRepo.save(managementCollection); try { List<MaxMgmtProcessLog> maxMgmtProcessLogs = MaximumTrackPlanUpdates.populateDifferences(null, managementCollection); if (maxMgmtProcessLogs != null && !maxMgmtProcessLogs.isEmpty()) { maxMgmtProcessLogs.forEach(maxMgmtProcessLog -> maxMgmtProcessLogRepository.save(maxMgmtProcessLog)); logger.info("Created " + maxMgmtProcessLogs.size() + " log records for new maximum with maxId: " + managementCollection.getMaxId()); } } catch (Exception e) { logger.error("Error logging new maximum creation for maxId: " + managementCollection.getMaxId(), e); } } else { updatePlanStatus(managementCollection); } return ResponseEntity.status(HttpStatus.CREATED).body(Collections.singletonMap("newMaximums", 1)); } catch (Exception e) { logger.error("Error in saveNewMaximum", e); throw e; } } private PlanAssignmentRequest toPlanAssignmentRequest(MaximumManagementCollection managementCollection) { PlanAssignmentRequest request = new PlanAssignmentRequest(); request.setAppliesTo(managementCollection.getAppliesTo()); request.setBenCatName(managementCollection.getBenCatName()); request.setStandard(managementCollection.getStandard()); request.setStateName(managementCollection.getState()); request.setCoc(managementCollection.getCocSeries().toString()); return request; } public Long updatePlanStatus(MaximumManagementCollection managementCollection) { try { MaximumManagementCollection existingCollection = maximumRepo.findByMaxId(managementCollection.getMaxId()); if (existingCollection != null) { List<MaxMgmtProcessLog> maxMgmtProcessLogs = MaximumTrackPlanUpdates.populateDifferences(existingCollection, managementCollection); if (maxMgmtProcessLogs != null && !maxMgmtProcessLogs.isEmpty()) { maxMgmtProcessLogs.forEach(maxMgmtProcessLog -> maxMgmtProcessLogRepository.save(maxMgmtProcessLog)); logger.info("Created " + maxMgmtProcessLogs.size() + " log records for updated maximum with maxId: " + managementCollection.getMaxId()); } } } catch (Exception e) { // Log the error but don't fail the update logger.error("Error tracking changes for maxId: " + managementCollection.getMaxId(), e); } Query query = new Query(); query.addCriteria(Criteria.where("maxId").is(managementCollection.getMaxId())); Update update = new Update(); if (null != managementCollection.getBenCatName()) { update.set(Constants.BEN_CAT_NAME, managementCollection.getBenCatName()); } if (null != managementCollection.getCocSeries()) { update.set(Constants.COC_SERIES, managementCollection.getCocSeries()); } if (null != managementCollection.getState()) { update.set(Constants.STATE, managementCollection.getState()); } if (null != managementCollection.getStandard()) { update.set(Constants.STANDARD, managementCollection.getStandard()); } if (null != managementCollection.getAppliesTo()) { update.set(Constants.APPLIES_TO, managementCollection.getAppliesTo()); } if (null != managementCollection.getCrossApplies()) { update.set(Constants.CROSS_APPLIES, managementCollection.getCrossApplies()); } if (null != managementCollection.getMaxType()) { update.set(Constants.MAX_TYPE, managementCollection.getMaxType()); } if (null != managementCollection.getMaxValue()) { update.set(Constants.MAX_VAL, managementCollection.getMaxValue()); } if (null != managementCollection.getFreqType()) { update.set(Constants.FREQ_TYPE, managementCollection.getFreqType()); } if (null != managementCollection.getFreqValue()) { update.set(Constants.FREQ_VAL, managementCollection.getFreqValue()); } if (null != managementCollection.getVisible()) { update.set(Constants.VISIBLE, managementCollection.getVisible()); } if (null != managementCollection.getSubCategory()) { update.set(Constants.SUBCATEGORY, managementCollection.getSubCategory()); } update.set("isBulkCascadeRequired", true); UpdateResult result; try { result = mongoTemplate.updateFirst(query, update, MaximumManagementCollection.class); } catch (Exception e) { throw new RuntimeException("Couldn't update the data for maxId: " + managementCollection.getMaxId(), e); } return result.getModifiedCount(); } @PostMapping("/deleteParentMaximum") public ResponseEntity<String> deleteParentMaximum(HttpServletRequest request, @RequestBody ParentMaximumRequest requestBody) { HttpSession session = request.getSession(); String currentUser = (String) session.getAttribute(SessionConstants.USER_NAME); return maximumManagementService.deleteParentMaximum(requestBody, currentUser); } @PostMapping("/deletePlanConfirm") @ResponseBody @SneakyThrows public ResponseEntity<Object> deletePlanConfirm(HttpServletRequest request, @RequestBody Integer maxIdVal) { HttpSession session = request.getSession(); String currentUser = (String) session.getAttribute(SessionConstants.USER_NAME); MaximumTrackPlanUpdates.setCurrentUser(currentUser); try { MaximumManagementCollection existingCollection = maximumRepo.findByMaxId(Long.valueOf(maxIdVal)); if (existingCollection != null) { List<MaxMgmtProcessLog> deletionLogs = MaximumTrackPlanUpdates.populateDeletionLog(existingCollection, true); if (deletionLogs != null && !deletionLogs.isEmpty()) { deletionLogs.forEach(log -> maxMgmtProcessLogRepository.save(log)); logger.info("Created " + deletionLogs.size() + " deletion log records for maxId: " + maxIdVal); } } } catch (Exception e) { logger.error("Error logging deletion for maxId: " + maxIdVal, e); } updateStatus(maxIdVal, Constants.currentDeleted); updateIsBulkCascadeRequired(maxIdVal, true); return ResponseEntity.status(HttpStatus.CREATED).body(Collections.singletonMap("deleteMaximums", 1)); } public Long updateIsBulkCascadeRequired(Integer maxId, boolean isBulkCascadeRequired) { Query query = new Query(); query.addCriteria(Criteria.where("maxId").is(maxId)); Update update = new Update(); update.set("isBulkCascadeRequired", isBulkCascadeRequired); UpdateResult result; try { result = mongoTemplate.updateFirst(query, update, MaximumManagementCollection.class); } catch (Exception e) { throw new RuntimeException("Couldn't update the data for maxId: " + maxId, e); } return result.getModifiedCount(); } public Long updateStatus(Integer maxId, String statusMessage) { Query query = new Query(); query.addCriteria(Criteria.where("maxId").is(maxId)); Update update = new Update(); update.set("status", statusMessage); UpdateResult result; try { result = mongoTemplate.updateFirst(query, update, MaximumManagementCollection.class); } catch (Exception e) { throw new RuntimeException("Couldn't update the data for maxId: " + maxId, e); } return result.getModifiedCount(); } @PostMapping("/cloneMaxManagement") @ResponseBody public ResponseEntity<Object> addNewMaxManagementRecords( @RequestBody CloneMaximumManagementRequestList cloneMaximumManagementRequestList, HttpServletRequest request) { maximumManagementService.cloneMaximumManagement(cloneMaximumManagementRequestList); return ResponseEntity.status(HttpStatus.CREATED).body(Collections.singletonMap("saveSuccess", "Maximum Management Changes Cloned Successfully")); } @PostMapping("/isBenCatExistForNewMaximumMgmt") @ResponseBody public ResponseEntity<Object> checkNewMaximumMgmtDataExist(@RequestBody MaximumManagementCollection managementCollection, HttpServletRequest request) { HttpSession session = request.getSession(); MaximumMgmtDDMapResponse maximumMgmtDDMapResponse; if (session.getAttribute("maximumMngDDMap") == null) { maximumMgmtDDMapResponse = maximumManagementService.getMaximumMgmtDropDownsMap(); session.setAttribute("maximumMngDDMap", maximumMgmtDDMapResponse); } else { maximumMgmtDDMapResponse = (MaximumMgmtDDMapResponse) session.getAttribute("maximumMngDDMap"); } PlanAssignmentRequest planAssignmentRequest = toPlanAssignmentRequest(managementCollection); List<MaximumManagementCollection> maximumList = maximumManagementService.getMaxSearchData(planAssignmentRequest); List<MaximumManagementCollection> allMatchingRecords = maximumList.stream() .filter(e -> e.getStatus().equals(Constants.active) && e.getBenCatName().equalsIgnoreCase(planAssignmentRequest.getBenCatName()) && e.getAppliesTo().equalsIgnoreCase(planAssignmentRequest.getAppliesTo())) .collect(Collectors.toList()); List<MaximumManagementCollection> identicalRecords = maximumList.stream() .filter(e -> e.getStatus().equals(Constants.active) && areMaximumsIdentical(e, managementCollection)) .collect(Collectors.toList()); logger.info("MaximumManagementController :: checkNewMaximumMgmtDataExist() Total matching records : " + allMatchingRecords.size() + ", Exact duplicates: " + identicalRecords.size()); Map<String, Integer> response = new HashMap<>(); response.put("existCount", allMatchingRecords.size()); // For backward compatibility response.put("identicalCount", identicalRecords.size()); // Count of completely identical records return ResponseEntity.status(HttpStatus.CREATED).body(response); } @PostMapping("/isBenCatExistForClone") @ResponseBody public ResponseEntity<Object> cloneMaxiMgmtBenCatNameExist(@RequestBody CloneMaximumManagementRequestList cloneMaximumManagementRequestList, HttpServletRequest request) { HttpSession session = request.getSession(); MaximumMgmtDDMapResponse maximumMgmtDDMapResponse; if (session.getAttribute("maximumMngDDMap") == null) { maximumMgmtDDMapResponse = maximumManagementService.getMaximumMgmtDropDownsMap(); session.setAttribute("maximumMngDDMap", maximumMgmtDDMapResponse); } else { maximumMgmtDDMapResponse = (MaximumMgmtDDMapResponse) session.getAttribute("maximumMngDDMap"); } return ResponseEntity.status(HttpStatus.CREATED).body(Collections.singletonMap("duplicateCount", maximumManagementService.getMaxiMgmtData(cloneMaximumManagementRequestList))); } @PostMapping("/getIfpDropdowns") @ResponseBody public List<String> getAllIFPDropdowns(HttpServletRequest request, @RequestBody Integer cocSeries) { Integer isCurrent = 1; MaximumMgmtDDMapResponse maximumMgmtDDMapResponse = maximumManagementService.getMaximumMgmtDropDownsMap(); PlIFPDropdowns plIFPDropdowns = plIFPDropdownsRepository.findByCocSeriesAndIsCurrent(cocSeries, isCurrent); List<String> productFamily = maximumMgmtDDMapResponse.getStandardMap().values().stream() .sorted() .collect(Collectors.toList()); if (plIFPDropdowns != null) { if (plIFPDropdowns.getProductFamily() != null) { productFamily = plIFPDropdowns.getProductFamily() .stream().filter(e -> e.getIsCurrent() == 1) .map(DropdownOption::getName) .sorted() .collect(Collectors.toList()); } } return productFamily; } @PostMapping("/maximumBulkCascade") @ResponseBody public ResponseEntity<Object> maximumBulkCascade(@RequestBody MaximumManagementCollection maxManagement, HttpServletRequest request) { HttpSession session = request.getSession(); String currentUser = (String) session.getAttribute(SessionConstants.USER_NAME); Long batchID = maximumManagementService.maximumBulkCascade(maxManagement, currentUser); if (batchID != null) { return ResponseEntity.status(HttpStatus.CREATED).body(Collections.singletonMap("batchID", batchID)); } else { return ResponseEntity.status(HttpStatus.CREATED).body(Collections.singletonMap("batchID", null)); } } @GetMapping("/maxManagement/product-family") @ResponseBody public List<String> findAllProductFamilies(@RequestParam String cocSeries) { return maximumManagementService.findAllProductFamilies(cocSeries); } private boolean areMaximumsIdentical(MaximumManagementCollection existing, MaximumManagementCollection newMaximum) { return safeEquals(existing.getCocSeries(), newMaximum.getCocSeries()) && safeEquals(existing.getState(), newMaximum.getState()) && safeEquals(existing.getStandard(), newMaximum.getStandard()) && safeEquals(existing.getBenCatName(), newMaximum.getBenCatName()) && safeEquals(existing.getMaxType(), newMaximum.getMaxType()) && safeEquals(existing.getMaxValue(), newMaximum.getMaxValue()) && safeEquals(existing.getAppliesTo(), newMaximum.getAppliesTo()) && safeEquals(existing.getCrossApplies(), newMaximum.getCrossApplies()) && safeEquals(existing.getFreqType(), newMaximum.getFreqType()) && safeEquals(existing.getFreqValue(), newMaximum.getFreqValue()); } private boolean safeEquals(Object obj1, Object obj2) { if (obj1 == null && obj2 == null) { return true; } if (obj1 == null || obj2 == null) { return false; } return obj1.toString().equalsIgnoreCase(obj2.toString()); } @GetMapping("/maxMgmtChangeSearch") public ModelAndView getMaxMgmtChangeSearchPage(HttpServletRequest request, ModelAndView model) { model.addObject("title", "Maximum Change Search"); model.setViewName("maxMgmtChangeSearch"); try { MaximumMgmtDDMapResponse maximumMgmtDDMapResponse; MaximumMgmtDDMapResponse maximumMgmtDDMapResponseForIEX; HttpSession session = request.getSession(); if (session.getAttribute("maximumMngDDMap") == null) { maximumMgmtDDMapResponse = maximumManagementService.getMaximumMgmtDropDownsMap(); maximumMgmtDDMapResponseForIEX = maximumManagementService.getMaximumMgmtDropDownsForIEXOrg();//product family for IEX maximumMgmtDDMapResponse.getStandardMap().clear(); maximumMgmtDDMapResponse.getStandardMap().putAll(maximumMgmtDDMapResponseForIEX.getStandardMap()); session.setAttribute("maximumMngDDMap", maximumMgmtDDMapResponse); } else { maximumMgmtDDMapResponse = (MaximumMgmtDDMapResponse) session.getAttribute("maximumMngDDMap"); } model.addObject("maximumDD", maximumMgmtDDMapResponse); List<String> benefitCategoryNames = productManagmentService.getMasterBenefitCategoryCollection() .stream() .map(MasterBenefitCategoryCollection::getBenefitCategoryValue) .sorted() .collect(Collectors.toList()); model.addObject("benefitCategoryNames", benefitCategoryNames); List<String> appliesTo = Constants.appliesTo.stream() .filter(s -> !s.trim().isEmpty()) .sorted() .collect(Collectors.toList()); model.addObject("appliesTo", appliesTo); return model; } catch (Exception exception) { return ErrorUtil.validateErrorMessage(exception); } } @PostMapping("/maxMgmtChangeSearch") @ResponseBody public List<List<String>> searchForChangedMaximum(@RequestBody MaximumChangedSearchRequest changedMaxSearchRequest) { List<List<String>> responseData = new ArrayList<>(); if ((changedMaxSearchRequest.getCocSeries() != null && !changedMaxSearchRequest.getCocSeries().isEmpty()) || (changedMaxSearchRequest.getState() != null && !changedMaxSearchRequest.getState().isEmpty()) || (changedMaxSearchRequest.getStandard() != null && !changedMaxSearchRequest.getStandard().isEmpty()) || (changedMaxSearchRequest.getBenCatName() != null && !changedMaxSearchRequest.getBenCatName().isEmpty()) || (changedMaxSearchRequest.getAppliesTo() != null && !changedMaxSearchRequest.getAppliesTo().isEmpty()) || (changedMaxSearchRequest.getModifiedBy() != null && !changedMaxSearchRequest.getModifiedBy().isEmpty()) || (changedMaxSearchRequest.getStartDate() != null && !changedMaxSearchRequest.getStartDate().toString().isEmpty()) || (changedMaxSearchRequest.getEndDate() != null && !changedMaxSearchRequest.getEndDate().toString().isEmpty()) ) { List<MaximumChangedSearchResponse> changedMaxList = maximumManagementService.getChangedMax(changedMaxSearchRequest); maximumManagementService.populateChangeTrackingResponse(responseData, changedMaxList); } return responseData; } @PostMapping(value = "/maxMgmtChangeTracking.xlsx") public void exportChangeTracking( @RequestBody List<List<String>> responseData, HttpServletResponse response) throws IOException { response.setContentType("application/octet-stream"); response.setHeader("Content-Disposition", "attachment; filename=changeTracking.xlsx"); ByteArrayInputStream stream = maximumManagementService.changeTrackingToExcelFile(responseData); if (stream != null && stream.available() > 0) { IOUtils.copy(stream, response.getOutputStream()); } else { response.sendError(HttpServletResponse.SC_NO_CONTENT, "No data to export"); } response.flushBuffer(); } }
package com.optum.ideate.service; import com.mongodb.client.result.UpdateResult; import com.optum.ideate.api.request.v1.DropdownOption; import com.optum.ideate.cbb.domain.COCSeries1; import com.optum.ideate.cbb.repo.CocSeries1Repository; import com.optum.ideate.model.request.CloneMaximumManagementRequest; import com.optum.ideate.model.request.CloneMaximumManagementRequestList; import com.optum.ideate.model.request.ParentMaximumRequest; import com.optum.ideate.model.request.MaximumChangedSearchRequest; import com.optum.ideate.model.response.MaximumChangedSearchResponse; import com.optum.ideate.model.response.MaximumMgmtDDMapResponse; import com.optum.ideate.model.response.PlanAssignmentRequest; import com.optum.ideate.mongodb.domain.*; import com.optum.ideate.mongodb.repo.*; import com.optum.ideate.planbuilder.domain.Standard; import com.optum.ideate.planbuilder.domain.State; import com.optum.ideate.planbuilder.repo.StandardRepository; import com.optum.ideate.planbuilder.repo.StateRepository; import com.optum.ideate.util.MaximumTrackPlanUpdates; import com.optum.ideate.util.PMConstants; import com.optum.ideate.utils.Constants; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.lang3.ObjectUtils; import org.apache.commons.lang3.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.mongodb.core.query.Criteria; import org.springframework.data.mongodb.core.query.Query; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.data.mongodb.core.query.Update; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; import java.text.SimpleDateFormat; import java.time.LocalDateTime; import java.time.ZoneId; import java.time.ZonedDateTime; import java.time.format.DateTimeFormatter; import java.util.*; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Function; import java.util.function.Predicate; import java.util.stream.Collectors; import static com.optum.ideate.aspose.Constants.currentDeleted; import static java.util.stream.Collectors.toMap; import java.io.ByteArrayInputStream; import org.apache.poi.ss.usermodel.*; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import java.io.ByteArrayOutputStream; import java.util.List; @Service public class MaximumManagementServiceImpl implements MaximumManagementService { @Autowired @Qualifier("mongoTemplate") private MongoTemplate mongoTemplate; @Autowired public CocSeries1Repository cocSeriesRepository; @Autowired MaximumManagementCollectionRepository maximumRepo; @Autowired MaxMgmtProcessLogRepository maxMgmtProcessLogRepository; @Autowired public StandardRepository standardRepository; @Autowired public StateRepository stateRepository; @Autowired public MaximumManagementCollectionRepository maxRepository; @Autowired private PortfolioEditorDropDownRepository portfolioEditorDropDownRepository; @Autowired public CocSeries1Repository cocSeries1Repository; @Autowired public PortfolioBulkEditRepository portfolioBulkEditRepository; @Autowired private PlPortfolioMgmtRepository plPortfolioMgmtRepository; @Autowired private PlIFPDropdownsRepository plIFPDropdownsRepository; @Autowired private MaxMgmtChangeRepository maxMgmtChangeRepository; private final static Logger logger = LoggerFactory.getLogger(MaximumManagementService.class); @Override public MaximumMgmtDDMapResponse getMaximumMgmtDropDownsMap() { Integer isCurrent = 1; MaximumMgmtDDMapResponse maximumMgmtDDMapResponse = new MaximumMgmtDDMapResponse(); try { Map<String, String> cocSeriesMap = cocSeries1Repository.findAllByIsCurrentOrderByCocSeriesDesc(true).stream() .collect(toMap(COCSeries1::getCocSeries, COCSeries1::getCocSeries)); Map<String, String> standardMap = standardRepository.findAllByIsCurrent(isCurrent).stream() .collect(toMap(Standard::getDescription, Standard::getDescription)); Map<String, String> stateMap = stateRepository.findAllByIsCurrent(isCurrent).stream() .collect(toMap(State::getStateAbbr, State::getStateAbbr)); maximumMgmtDDMapResponse.getCocSeriesMap().putAll(cocSeriesMap); maximumMgmtDDMapResponse.getStandardMap().putAll(standardMap); maximumMgmtDDMapResponse.getStateMap().putAll(stateMap); } catch (Exception e) { logger.error(String.valueOf(e.getStackTrace())); } return maximumMgmtDDMapResponse; } @Override public ResponseEntity<String> deleteParentMaximum(ParentMaximumRequest requestBody, String currentUser) { MaximumTrackPlanUpdates.setCurrentUser(currentUser); List<Integer> maxIdsList = findMatchingIds(requestBody); try { for (Integer maxId : maxIdsList) { try { MaximumManagementCollection existingCollection = maximumRepo.findByMaxId(Long.valueOf(maxId)); if (existingCollection != null) { List<MaxMgmtProcessLog> deletionLogs = MaximumTrackPlanUpdates.populateDeletionLog(existingCollection, true); if (deletionLogs != null && !deletionLogs.isEmpty()) { deletionLogs.forEach(log -> maxMgmtProcessLogRepository.save(log)); logger.info("Created " + deletionLogs.size() + " deletion log records for maxId: " + maxId); } } } catch (Exception e) { logger.error("Error logging deletion for maxId: " + maxId, e); } updateStatus(maxId,currentDeleted); updateIsBulkCascadeRequired(maxId, true); MaximumManagementCollection managementCollection = maximumRepo.findByMaxId(Long.valueOf(maxId)); } return ResponseEntity.ok("Parent maximums deleted successfully."); } catch (Exception e) { return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body("An error occurred while deleting the parent maximums."); } } public Long updateIsBulkCascadeRequired(Integer maxId, boolean isBulkCascadeRequired) { Query query = new Query(); query.addCriteria(Criteria.where("maxId").is(maxId)); Update update = new Update(); update.set("isBulkCascadeRequired", isBulkCascadeRequired); UpdateResult result; try { result = mongoTemplate.updateFirst(query, update, MaximumManagementCollection.class); } catch (Exception e) { throw new RuntimeException("Couldn't update the data for maxId: " + maxId, e); } return result.getModifiedCount(); } public Long updateStatus(Integer maxId, String statusMessage) { Query query = new Query(); query.addCriteria(Criteria.where("maxId").is(maxId)); Update update = new Update(); update.set("status", statusMessage); UpdateResult result; try { result = mongoTemplate.updateFirst(query, update, MaximumManagementCollection.class); } catch (Exception e) { throw new RuntimeException("Couldn't update the data for maxId: " + maxId, e); } return result.getModifiedCount(); } public List<Integer> findMatchingIds(ParentMaximumRequest request) { Query query = new Query(); query.addCriteria(Criteria.where("benCatName").is(request.getBenCatName()) .and("cocSeries").is(request.getCocSeries()) .and("standard").is(request.getStandard()) .and("state").is(request.getState()) .and("status").nin(currentDeleted, com.optum.ideate.aspose.Constants.deleted)); query.fields().include("maxId"); List<MaximumManagementCollection> results = mongoTemplate.find(query, MaximumManagementCollection.class); return results.stream().map(MaximumManagementCollection::getMaxId).map(Long::intValue).collect(Collectors.toList()); } @Override public List<MaximumManagementCollection> getMaxSearchData(PlanAssignmentRequest planAssignmentRequest) { List<MaximumManagementCollection> maxList = new ArrayList<>(); try { Criteria criteria = new Criteria(); if (StringUtils.isNotEmpty(planAssignmentRequest.getCoc())) { List<Long> cocList = Arrays.stream(planAssignmentRequest.getCoc().split(",")) .map(String::trim) .map(Long::parseLong) .toList(); criteria.and("cocSeries").in(cocList); } if (StringUtils.isNotEmpty(planAssignmentRequest.getStateName())) { List<String> stateList = Arrays.stream(planAssignmentRequest.getStateName().split(",")) .map(String::trim) .toList(); criteria.and("state").in(stateList); } if (StringUtils.isNotEmpty(planAssignmentRequest.getStandard())) { List<String> standardList = Arrays.stream(planAssignmentRequest.getStandard().split(",")) .map(String::trim) .toList(); criteria.and("standard").in(standardList); } Query query = new Query(criteria); maxList = mongoTemplate.find(query, MaximumManagementCollection.class); maxList.sort(Comparator.comparing(MaximumManagementCollection::getBenCatName)); } catch (Exception e) { logger.error(String.valueOf(e.getStackTrace())); } return maxList; } @Override public List<MaximumManagementCollection> getAllMaxManagementData() { List<MaximumManagementCollection> maxList = new ArrayList<>(); try { maxList = maxRepository.findAll(); maxList = maxList.stream() .filter(e -> Constants.active.equals(e.getStatus())) .sorted(Comparator .comparing((MaximumManagementCollection m) -> safeString(m.getBenCatName())) .thenComparing(m -> safeString(String.valueOf(m.getCocSeries()))) .thenComparing(m -> safeString(m.getState())) .thenComparing(m -> safeString(m.getStandard())) ) .collect(Collectors.toList()); } catch (Exception e) { logger.error("Error fetching all MaximumManagement data: " + e.getMessage()); } return maxList; } private String safeString(String s) { return s == null ? "" : s.trim().toLowerCase(); } @Override public MaximumManagementCollection deleteByMaxId(Long maxId) { MaximumManagementCollection max = maxRepository.findByMaxId(maxId); if (max != null) { try { max.setStatus(Constants.deleted); maxRepository.save(max); } catch (Exception e) { e.getStackTrace(); } } return max; } @Override public MaximumManagementCollection findByMaxId(Long maxId) { MaximumManagementCollection max = maxRepository.findByMaxId(maxId); return max; } @Override public void cloneMaximumManagement(CloneMaximumManagementRequestList cloneMaximumManagementRequestList) { if (!cloneMaximumManagementRequestList.getCloneMaximumManagementRequestList().isEmpty()) { for (CloneMaximumManagementRequest cloneReq : cloneMaximumManagementRequestList.getCloneMaximumManagementRequestList()) { MaximumManagementCollection max = maxRepository.findTopByOrderByMaxIdDesc(); Long maxIdVal = max.getMaxId(); MaximumManagementCollection maximumManagementCollection = new MaximumManagementCollection(); maximumManagementCollection.setMaxId(maxIdVal + 1); maximumManagementCollection.setAppliesTo(cloneReq.getCloneAppliesTo()); maximumManagementCollection.setBenCatName(cloneReq.getCloneBenefitCategoryName()); maximumManagementCollection.setState(cloneReq.getCloneState()); maximumManagementCollection.setCocSeries(cloneReq.getCloneCoc()); maximumManagementCollection.setStandard(cloneReq.getCloneStandard()); maximumManagementCollection.setFreqType(cloneReq.getCloneFreqType()); maximumManagementCollection.setFreqValue(cloneReq.getCloneFreqValue()); maximumManagementCollection.setMaxValue(cloneReq.getCloneMaxValue()); maximumManagementCollection.setMaxType(cloneReq.getCloneMaxType()); maximumManagementCollection.setCrossApplies(cloneReq.getCloneCrossApplies()); maximumManagementCollection.setStatus(Constants.active); maximumManagementCollection.setBulkCascadeRequired(true); maximumManagementCollection.setSubCategory(cloneReq.getCloneSubCategory()); maximumManagementCollection.setVisible(cloneReq.getCloneVisible()); maxRepository.save(maximumManagementCollection); } } } @Override public MaximumMgmtDDMapResponse getMaximumMgmtDropDownsForIEXOrg() { List<String> dropDownsForIEXOrg = null; try { PortfolioEditorDropDownCollection portfolioEditorDropDownCollection = portfolioEditorDropDownRepository.findByPageName("Portfolio Editor"); Map<String, String> standardMap = portfolioEditorDropDownCollection.getProductFamily().stream() .collect(toMap(DropdownOption::getName, DropdownOption::getName)); dropDownsForIEXOrg = standardMap.values().stream().collect(Collectors.toCollection(ArrayList::new)); } catch (Exception e) { logger.error(e.getMessage()); } MaximumMgmtDDMapResponse maximumMgmtDDMapResponse = new MaximumMgmtDDMapResponse(); try { Map<String, String> standardMap = dropDownsForIEXOrg.stream() .collect(toMap(Function.identity(), Function.identity())); maximumMgmtDDMapResponse.getStandardMap().putAll(standardMap); } catch (Exception e) { } return maximumMgmtDDMapResponse; } @Override public Long getMaxiMgmtData(CloneMaximumManagementRequestList cloneMaximumManagementRequestList) { long duplicateCount = 0; if (CollectionUtils.isNotEmpty(cloneMaximumManagementRequestList.getCloneMaximumManagementRequestList())) { PlanAssignmentRequest planAssignmentRequest = new PlanAssignmentRequest(); planAssignmentRequest.setCoc("" + cloneMaximumManagementRequestList.getCloneMaximumManagementRequestList().get(0).getCloneCoc()); planAssignmentRequest.setStateName(cloneMaximumManagementRequestList.getCloneMaximumManagementRequestList().get(0).getCloneState()); planAssignmentRequest.setStandard(cloneMaximumManagementRequestList.getCloneMaximumManagementRequestList().get(0).getCloneStandard()); List<CloneMaximumManagementRequest> cloneMaximumManagementList = cloneMaximumManagementRequestList.getCloneMaximumManagementRequestList(); List<MaximumManagementCollection> maxiMgmtList = maxRepository.findByCocSeriesAndStateAndStandard(Long.parseLong(planAssignmentRequest.getCoc()), planAssignmentRequest.getStateName(), planAssignmentRequest.getStandard()); List<MaximumManagementCollection> filteredMaxiMgmtList = maxiMgmtList.stream() .filter(e -> e.getStatus().equals(Constants.active)) .collect(Collectors.toList()); duplicateCount = filteredMaxiMgmtList.stream() .filter(maxiMgmt -> cloneMaximumManagementList.stream() .anyMatch(filteredMaxiMgmt -> filteredMaxiMgmt.getCloneBenefitCategoryName().equals(maxiMgmt.getBenCatName()))) .count(); logger.info("MaximumManagementServiceImpl :: getMaxiMgmtData() Duplicate BenCat name count : " + duplicateCount); } return duplicateCount; } @Override public Long maximumBulkCascade(MaximumManagementCollection maxManagement, String currentUser) { try { // Insert into pl_portfolio_bulk_edit table. PortfolioBulkEdit portfolioBulkEdit = new PortfolioBulkEdit(); portfolioBulkEdit.setType("Bulk Cascade"); portfolioBulkEdit.setCascadeType("Maximum Management"); portfolioBulkEdit.setBatchStatus(PMConstants.STATUS_NEW); portfolioBulkEdit.setCreatedBy(currentUser); portfolioBulkEdit.setCreatedOn(getCurrentDateFormat()); portfolioBulkEdit.setBatchID(portfolioBulkEditRepository.findFirstByOrderByBatchIDDesc().getBatchID() + 1); List<BulkEditPlans> planList = new ArrayList<>(); List<MaximumManagementCollection> maxMgmtBulkCascadeList = maxRepository.findByIsBulkCascadeRequired(true); if(CollectionUtils.isNotEmpty(maxMgmtBulkCascadeList)) { for(MaximumManagementCollection maximumCollection : maxMgmtBulkCascadeList) { //List<PlPortfolioMgmtCollection> plPortfolioMgmtCollectionList = plPortfolioMgmtRepository.findByPlanDetailsCocSeriesAndPlanDetailsStateAbbrAndPlanDetailsStandard(maxManagement.getCocSeries(), maxManagement.getState(), maxManagement.getStandard()); List<PlPortfolioMgmtCollection> plPortfolioMgmtCollectionList = plPortfolioMgmtRepository.findByPlanDetailsCocSeriesAndPlanDetailsStateAbbrAndPlanDetailsStandardAndPlanDetailsStatusNot(maximumCollection.getCocSeries(), maximumCollection.getState(), maximumCollection.getStandard(), Constants.deleted); if(CollectionUtils.isNotEmpty(plPortfolioMgmtCollectionList)) { for (int i = 0; i < plPortfolioMgmtCollectionList.size(); i++) { if (plPortfolioMgmtCollectionList.get(i).getParentPlanAssignmentID() == null && !Constants.deleted.equalsIgnoreCase(plPortfolioMgmtCollectionList.get(i).getPlanDetails().getStatus())) { BulkEditPlans bulkEditPlans = new BulkEditPlans(); bulkEditPlans.setPlanAssignmentId(plPortfolioMgmtCollectionList.get(i).getPlanAssignmentID().toString()); bulkEditPlans.setPlanCode(plPortfolioMgmtCollectionList.get(i).getPlanDetails().getPlanCode()); bulkEditPlans.setRowNumber(null); bulkEditPlans.setCocSeries(plPortfolioMgmtCollectionList.get(i).getPlanDetails().getCocSeries()); bulkEditPlans.setStateAbbr(plPortfolioMgmtCollectionList.get(i).getPlanDetails().getStateAbbr()); bulkEditPlans.setProductFamily(plPortfolioMgmtCollectionList.get(i).getPlanDetails().getStandard()); bulkEditPlans.setPlanStatus(PMConstants.STATUS_NEW); bulkEditPlans.setPlanStatusMessage("Added in batch for update"); bulkEditPlans.setFieldName(""); bulkEditPlans.setNewValue(""); bulkEditPlans.setChangeReason("Bulk Cascade"); planList.add(bulkEditPlans); } } } } } // Remove duplicate planAssignmentId from planList as single plan has multiple BenCat with limits planList = planList.stream().filter(distinctByKey(BulkEditPlans::getPlanAssignmentId)).collect(Collectors.toList()); portfolioBulkEdit.setPlans(planList); portfolioBulkEdit = portfolioBulkEditRepository.save(portfolioBulkEdit); if (portfolioBulkEdit != null) { for (MaximumManagementCollection maxMgmtCollection : maxMgmtBulkCascadeList) { maxMgmtCollection.setBulkCascadeRequired(false); maxRepository.save(maxMgmtCollection); } return portfolioBulkEdit.getBatchID(); } else { return null; } } catch (Exception e) { logger.error("Error in MaximumManagementServiceImpl :: maximumBulkCascade() : " + e.getMessage()); return null; } } @Override public List<String> findAllProductFamilies(String cocSeries) { Set<String> productFamilies = new HashSet<>(); try { if (StringUtils.isNotEmpty(cocSeries)) { if (cocSeries.contains(",")) { String[] arrOfStr = cocSeries.split(","); for (String coc : arrOfStr) { PlIFPDropdowns plIFPDropdowns = plIFPDropdownsRepository.findByCocSeriesAndIsCurrent(Integer.parseInt(coc.trim()), 1); if (ObjectUtils.isNotEmpty(plIFPDropdowns) && ObjectUtils.isNotEmpty(plIFPDropdowns.getProductFamily())) { plIFPDropdowns.getProductFamily() .stream() .filter(e -> e.getIsCurrent() == 1) .map(DropdownOption::getName) .forEach(productFamilies::add); } } } else { PlIFPDropdowns plIFPDropdowns = plIFPDropdownsRepository.findByCocSeriesAndIsCurrent(Integer.parseInt(cocSeries), 1); if (ObjectUtils.isNotEmpty(plIFPDropdowns) && ObjectUtils.isNotEmpty(plIFPDropdowns.getProductFamily())) { plIFPDropdowns.getProductFamily() .stream() .filter(e -> e.getIsCurrent() == 1) .map(DropdownOption::getName) .forEach(productFamilies::add); } } } else { PortfolioEditorDropDownCollection portfolioEditorDropDownCollection = portfolioEditorDropDownRepository.findByPageName("Portfolio Editor"); portfolioEditorDropDownCollection.getProductFamily() .stream() .map(DropdownOption::getName) .forEach(productFamilies::add); } } catch (Exception e) { logger.error("Error in findProductFamilyByCocSeries::{}", e.getMessage()); } List<String> sortedFamilies = new ArrayList<>(productFamilies); Collections.sort(sortedFamilies); return sortedFamilies; } public static <T> Predicate<T> distinctByKey(com.google.common.base.Function<? super T, ?> keyExtractor) { Set<Object> seen = ConcurrentHashMap.newKeySet(); return t -> seen.add(keyExtractor.apply(t)); } private String getCurrentDateFormat() { SimpleDateFormat dateFormat = new SimpleDateFormat(PMConstants.BATCH_DATE_FORMAT); Date date = new Date(); String formatdDate = dateFormat.format(date); return formatdDate; } @Override public List<MaximumChangedSearchResponse> getChangedMax(MaximumChangedSearchRequest changedMaxSearchRequest) { List<MaximumChangedSearchResponse> maximumSearchDataList = maxMgmtChangeRepository.getMaximumSearchData(changedMaxSearchRequest); return maximumSearchDataList; } @Override public void populateChangeTrackingResponse(List<List<String>> responseData, List<MaximumChangedSearchResponse> changedMaxList) { Comparator<MaximumChangedSearchResponse> maxComparator = (p1, p2) -> p2.getModifiedOn().compareTo(p1.getModifiedOn()); changedMaxList.stream().filter(max -> max.getModifiedOn() != null).sorted(maxComparator).forEach(changedMax -> { List<String> max = new ArrayList<>(); if (!changedMax.getChangedField().equalsIgnoreCase("Status")) { max.add(changedMax.getCocSeries()); max.add(changedMax.getState()); max.add(changedMax.getStandard()); max.add(changedMax.getBenCatName()); max.add(changedMax.getChangedField()); max.add(changedMax.getOriginalValue()); max.add(changedMax.getNewValue()); max.add(changedMax.getModifiedBy()); max.add(convertUtcToSpecificTimezone(changedMax.getModifiedOn(), "America/Chicago")); responseData.add(max); } }); } public static String convertUtcToSpecificTimezone(String utcTime, String targetTimezone) { // Define the input format DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); // Parse the UTC time LocalDateTime localDateTime = LocalDateTime.parse(utcTime, inputFormatter); // Convert to ZonedDateTime in UTC ZonedDateTime utcZonedDateTime = localDateTime.atZone(ZoneId.of("UTC")); // Convert to the specified timezone ZonedDateTime targetZonedDateTime = utcZonedDateTime.withZoneSameInstant(ZoneId.of(targetTimezone)); // Define the output format DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); // Format the result return targetZonedDateTime.format(outputFormatter); } @Override public ByteArrayInputStream changeTrackingToExcelFile(List<List<String>> responseData) { try (Workbook workbook = new XSSFWorkbook()) { Sheet sheet = workbook.createSheet("Change Tracking"); // Add bold header row String[] columns = { "COC Series", "State", "Product Family", "Benefit Category", "Field", "Original Value", "New Value", "Modified By", "Modified On" }; // Create bold font CellStyle headerStyle = workbook.createCellStyle(); Font font = workbook.createFont(); font.setBold(true); headerStyle.setFont(font); Row header = sheet.createRow(0); for (int i = 0; i < columns.length; i++) { Cell cell = header.createCell(i); cell.setCellValue(columns[i]); cell.setCellStyle(headerStyle); } // Write data rows for (int i = 0; i < responseData.size(); i++) { Row row = sheet.createRow(i + 1); // Start from row 1 (row 0 is header) List<String> rowData = responseData.get(i); for (int j = 0; j < rowData.size(); j++) { row.createCell(j).setCellValue(rowData.get(j)); } } ByteArrayOutputStream out = new ByteArrayOutputStream(); workbook.write(out); return new ByteArrayInputStream(out.toByteArray()); } catch (Exception e) { logger.error("Error generating Excel file: ", e); return new ByteArrayInputStream(new byte[0]); } } }

can u make the new endpoint similarly no need for new domain and dto
