i am working on creating a automates testing for app called becca using deepeval but most of my test cases are failing attaching all the relavant code pieces and excel generated please help me debig what could be possible issues and suggest fixes without disturbing any core logic
analyse the excel also thoroughly
also let me know if u need any other code files to debug better 


import allure
import pytest

from settings import BECCA_XL
from tests.vikings.fw.common.CommonUtils import CommonUtils
from tests.vikings.fw.common.FW import FW

from ..ui_pages.BeccaPage import BeccaPage
from ..ui_pages.LogoutPage import LogoutPage


COLUMNS_ORDER = [
    "actual_prompt",
    "expected_response",
    "actual_response",
    "ui_status",
    "ui_error",
    "Response time(secs)",
    "eval_threshold",
    "gEval_score",
    "gEval_reason",
    "eval_status",
    "eval_error",
]
from playwright.sync_api import TimeoutError as PlaywrightTimeoutError
import allure

def test_login_becca_helper(request, becca_page, testcase, rows_accumulator):
    request.node.COLUMNS_ORDER = COLUMNS_ORDER

    becca = BeccaPage(becca_page)
    logout = LogoutPage(becca_page)

    try:
        CommonUtils.setupTest(testcase)

        becca.open_becca()
        ui_row = becca.execute_testcase(testcase, rows_accumulator)

        # ✅ Always evaluate before attempting logout
        becca.evaluate_testcase(ui_row, rows_accumulator)

        # ✅ Logout should not fail BECCA validation
        try:
            logout.logout()
        except PlaywrightTimeoutError as e:
            # Attach debug but don't fail
            allure.attach(
                str(e),
                name="Logout skipped (Tools not found)",
                attachment_type=allure.attachment_type.TEXT
            )
            becca.attach_screenshot("Logout skipped - Tools not found")

    except Exception as e:
        CommonUtils.handleException(testcase, rows_accumulator, e)
        raise

@pytest.mark.parametrize("testcase", FW.get_test_data(BECCA_XL))
@pytest.mark.uieval
@allure.feature("becca")
@allure.story("ui_eval_e2e")
def test_login_becca_logout_e2e(request, becca_page, testcase, rows_accumulator):
    test_login_becca_helper(request, becca_page, testcase, rows_accumulator)


@pytest.mark.parametrize("testcase", FW.get_test_data(BECCA_XL)[:1])
@pytest.mark.smoke
@allure.feature("becca")
@allure.story("ui_eval_e2e")
def test_login_becca_logout_smoke(request, becca_page, testcase, rows_accumulator):
    test_login_becca_helper(request, becca_page, testcase, rows_accumulator)

import logging
import traceback
import time
import re
from typing import Dict, Any, Tuple, List

import allure

from tests.vikings.apps.becca.config.Constants import Constants
from tests.vikings.conftest import THRESHOLD
from tests.vikings.fw.common.Results import Results
from tests.vikings.fw.ui.BasePage import BasePage
from tests.vikings.fw.utils import get_multiple_scores


class BeccaPage(BasePage):
    CHAT_INPUT_SELECTOR = ".input-section textarea[matInput]"
    SUBMIT_BUTTON_SELECTOR = "button.submit-button"
    START_NEW_CHAT_SELECTOR = 'button:has-text("Start New Chat")'
    CHAT_MESSAGE_SELECTOR = "div.chat-box app-chat-message"

    GENERATION_START_TIMEOUT_SECS = 10
    GENERATION_END_TIMEOUT_SECS = 180

    def __init__(self, page):
        self.page = page

    def open_becca(self):
        with allure.step("Open Becca UI"):
            self.page.goto(Constants.BECCA_URL, wait_until="domcontentloaded")

    def start_new_chat_if_present(self):
        with allure.step("Start New Chat (if present)"):
            try:
                btn = self.page.locator(self.START_NEW_CHAT_SELECTOR)
                if btn.count() > 0 and btn.first.is_visible():
                    btn.first.click()
                    self.sleep(1)
            except Exception:
                pass

    def _wait_for_button_text(self, selector: str, expected_text: str, timeout_secs: int):
        end = time.time() + timeout_secs
        btn = self.page.locator(selector).first

        while time.time() < end:
            try:
                if btn.is_visible():
                    txt = btn.inner_text().strip()
                    if txt == expected_text:
                        return
            except Exception:
                pass
            time.sleep(0.25)

        raise TimeoutError(f"Button '{selector}' did not show text '{expected_text}' within {timeout_secs}s")

    def _get_message_count(self) -> int:
        try:
            return self.page.locator(self.CHAT_MESSAGE_SELECTOR).count()
        except Exception:
            return 0

    def _wait_for_message_count_increase(self, previous_count: int, timeout_secs: int = 15):
        end = time.time() + timeout_secs
        while time.time() < end:
            current = self._get_message_count()
            if current > previous_count:
                return
            time.sleep(0.25)

    def _get_latest_message_text(self) -> str:
        last = self.page.locator(self.CHAT_MESSAGE_SELECTOR).last
        last.wait_for(state="visible", timeout=30000)
        return last.inner_text().strip()

    def send_prompt_and_wait(self, prompt: str) -> str:
        with allure.step("Send prompt in Becca and wait for response"):
            input_box = self.page.locator(self.CHAT_INPUT_SELECTOR).first
            submit_btn = self.page.locator(self.SUBMIT_BUTTON_SELECTOR).first

            prev_count = self._get_message_count()

            input_box.wait_for(state="visible", timeout=30000)
            input_box.click()
            input_box.fill(prompt)

            submit_btn.wait_for(state="visible", timeout=30000)
            submit_btn.click()

            self._wait_for_button_text(self.SUBMIT_BUTTON_SELECTOR, "Cancel", self.GENERATION_START_TIMEOUT_SECS)
            self._wait_for_button_text(self.SUBMIT_BUTTON_SELECTOR, "Submit", self.GENERATION_END_TIMEOUT_SECS)

            self._wait_for_message_count_increase(prev_count, timeout_secs=15)
            response_text = self._get_latest_message_text()
            self.attach_screenshot("Becca response Screenshot")
            return response_text

    def run_prompt_and_get_response(self, prompt: str) -> Tuple[str, float]:
        start = time.time()
        response = self.send_prompt_and_wait(prompt)
        return response, round(time.time() - start, 2)


    def _normalize_for_match(self, s: str) -> str:
        if s is None:
            return ""
        s = str(s).lower().replace("\n", " ").replace("\t", " ")
        s = re.sub(r"[^\w\s%$.-]", " ", s)    # remove punctuation to stabilize matching
        s = re.sub(r"\s+", " ", s).strip()
        return s

    def _format_prompt_with_row_values(self, prompt: str, testcase: Dict[str, Any]) -> str:
        if not prompt:
            return ""

        def repl(match):
            key = match.group(1)  # after $
            if key in testcase and str(testcase.get(key, "")).strip():
                return str(testcase.get(key)).strip()

            lower_map = {str(k).lower(): k for k in testcase.keys()}
            if key.lower() in lower_map:
                real_key = lower_map[key.lower()]
                val = str(testcase.get(real_key, "")).strip()
                return val if val else match.group(0)

            return match.group(0)

        return re.sub(r"\$(\w+)", repl, prompt).strip()

    def _validate_becca_response(
            self,
            actual_response: str,
            expected_response: str,
            validation_text: str,
            testcase: Dict[str, Any],
    ) -> Tuple[str, str]:
        actual_norm = self._normalize_for_match(actual_response)

        # Fail fast on empty / none-like responses
        if not actual_response or actual_norm in {"none", ""}:
            return "failed", "ACTUAL_RESPONSE is empty/none"

        validation_text = (validation_text or "").strip()

        # CASE 1: validation_text present -> token based validation
        if validation_text:
            raw_tokens = [t.strip() for t in validation_text.split(",") if t.strip()]
            col_map = {str(k).strip().lower(): k for k in testcase.keys()}

            resolved_tokens: List[str] = []
            for token in raw_tokens:
                token_l = token.lower()
                if token_l in col_map:
                    col_name = col_map[token_l]
                    col_val = str(testcase.get(col_name, "")).strip()
                    resolved_tokens.append(col_val if col_val else token)
                else:
                    resolved_tokens.append(token)

            missing = []
            for tok in resolved_tokens:
                tok_norm = self._normalize_for_match(tok)
                if tok_norm and tok_norm not in actual_norm:
                    missing.append(tok)

            if missing:
                return "failed", f"Missing tokens in ACTUAL_RESPONSE: {missing}"
            return "passed", ""

        # CASE 2: no validation_text -> compare expected and actual (normalized contains)
        expected_response = (expected_response or "").strip()
        if expected_response:
            exp_norm = self._normalize_for_match(expected_response)
            if exp_norm and exp_norm in actual_norm:
                return "passed", ""
            return "failed", "Expected response not found in actual response (normalized contains check)."

        # CASE 3: both empty -> pass since actual is non-empty already
        return "passed", ""


    def execute_testcase(self, testcase: Dict[str, Any], rows_accumulator: Dict[str, Any]):
        with allure.step("Ask a Question (Becca UI)"):

            expected = str(testcase.get("expected_response", testcase.get("expected_answer", ""))).strip()
            raw_prompt = str(testcase.get("prompt", "")).strip()
            row_key = raw_prompt

            validation_text = str(testcase.get("validation_text", "")).strip()

            prompt = self._format_prompt_with_row_values(raw_prompt, testcase)

            allure.dynamic.title(prompt if prompt else "Becca testcase")

            test_failure_reason = ""
            try:
                actual_response, time_taken = self.run_prompt_and_get_response(prompt)
                Results.report_event(f"Becca prompt response time: {time_taken}")

                ui_status, test_failure_reason = self._validate_becca_response(
                    actual_response=actual_response,
                    expected_response=expected,
                    validation_text=validation_text,
                    testcase=testcase
                )

                result = {
                    "actual_prompt": prompt,
                    "expected_response": expected,
                    "actual_response": actual_response,
                    "ui_status": ui_status,
                    "Response time(secs)": time_taken,
                    "ui_error": test_failure_reason or ""
                }
                merged = {**testcase, **result}

                Results.report_event("Becca question searched successfully: " + prompt)
                Results.report_event("validation_text: " + validation_text)
                Results.report_event("LLM response: " + actual_response)
                self.attach_screenshot("Becca question Screenshot")

            except Exception as e:
                logging.info(f"UI execution exception: {e}")
                allure.attach(traceback.format_exc(), name="UI execution exception",
                              attachment_type=allure.attachment_type.TEXT)
                result = {
                    "actual_prompt": prompt,
                    "expected_response": expected,
                    "actual_response": "error while fetching ui response",
                    "ui_status": "failed",
                    "Response time(secs)": "0",
                    "ui_error": f"{str(e)}"
                }
                merged = {**testcase, **result}
                test_failure_reason = f"UI execution exception: {str(e)}"

            ui_row = merged
            rows_accumulator[row_key] = ui_row

            Results.report_event_assert_bool(
                ui_row["ui_status"] == "passed",
                f"prompt failed: {ui_row['actual_prompt']}" +
                (f" | {test_failure_reason}" if test_failure_reason else "")
            )
            return ui_row


    def evaluate_testcase(self, ui_row: Dict[str, Any], rows_accumulator: Dict[str, Any]):
        with allure.step("Evaluate Becca Testcase"):
            try:
                threshold = THRESHOLD

                if not ui_row.get("expected_response", ""):
                    ui_row["expected_response"] = ui_row.get("actual_response", "")

                eval_payload = {
                    "question": ui_row.get("actual_prompt", ""),
                    "llmAnswer": ui_row.get("actual_response", ""),
                    "groundAnswer": ui_row.get("expected_response", ""),
                    "contextualPrecision": False,
                    "contextualRecall": False,
                    "faithfulness": False,
                    "gEval": True
                }

                data = get_multiple_scores(eval_payload)
                gEval_score = data.get("gEval", {}).get("score", 0)
                gEval_reason = data.get("gEval", {}).get("reason", "")

                pass_geval = gEval_score >= threshold

                eval_result = {
                    "eval_threshold": threshold,
                    "gEval_score": gEval_score,
                    "gEval_reason": gEval_reason,
                    "eval_error": "",
                    "eval_status": "passed" if pass_geval else "failed"
                }

                merged_ui_eval = {**ui_row, **eval_result}

            except Exception as e:
                logging.info(f"Evaluation exception: {e}")
                allure.attach(traceback.format_exc(), name="Evaluation exception",
                              attachment_type=allure.attachment_type.TEXT)

                eval_result = {
                    "eval_threshold": "",
                    "gEval_score": 0,
                    "gEval_reason": "evaluation error",
                    "eval_status": "failed",
                    "eval_error": f"{str(e)}"
                }
                merged_ui_eval = {**ui_row, **eval_result}

            rows_accumulator[merged_ui_eval.get("actual_prompt", "")] = merged_ui_eval
            return merged_ui_eval

import allure
from playwright.sync_api import Page, expect
from tests.vikings.apps.becca.config.Constants import Constants
from tests.vikings.fw.common.FW import FW
from tests.vikings.fw.common.Results import Results
from tests.vikings.fw.ui.BasePage import BasePage

class LoginPage(BasePage):
    AZURE_USERNAME_INPUT = 'input[name="loginfmt"]'
    AZURE_PASSWORD_INPUT = 'input[name="passwd"]'
    AZURE_SUBMIT_BUTTON = 'input[type="submit"]'
    AZURE_STAY_SIGNED_IN_YES = 'input[value="Yes"]'
    def __init__(self, page: Page):
        super().__init__(page)
    def login(self):
        with allure.step("Login to BECCA via Azure AD"):
            username = FW.get_env("BECCA_APP_CIRRUS_UI_USERNAME")
            password = FW.get_env("BECCA_APP_CIRRUS_UI_PASSWORD")
            if not username or not password:
                Results.report_event(
                    "Missing BECCA_APP_CIRRUS_UI_USERNAME or BECCA_APP_CIRRUS_UI_PASSWORD"
                )
                raise RuntimeError("Credentials not provided via environment variables")
            self.page.goto(Constants.BECCA_URL, wait_until="domcontentloaded")
            self.page.wait_for_selector(self.AZURE_USERNAME_INPUT, timeout=30000)
            self.page.fill(self.AZURE_USERNAME_INPUT, username)
            self.page.click(self.AZURE_SUBMIT_BUTTON)
            self.page.wait_for_selector(self.AZURE_PASSWORD_INPUT, timeout=30000)
            self.page.fill(self.AZURE_PASSWORD_INPUT, password)
            self.page.click(self.AZURE_SUBMIT_BUTTON)
            try:
                self.page.wait_for_selector(self.AZURE_STAY_SIGNED_IN_YES, timeout=5000)
                self.page.click(self.AZURE_STAY_SIGNED_IN_YES)
            except Exception:
                pass
            self.page.wait_for_load_state("networkidle", timeout=30000)
            expect(self.page).not_to_have_url(lambda url: "login.microsoftonline.com" in url)
            Results.report_event("User logged in successfully")
            self.attach_screenshot("Login Successful")

# python
import allure
from playwright.sync_api import Page, TimeoutError as PlaywrightTimeoutError
from tests.vikings.fw.common.Results import Results
from tests.vikings.fw.ui.BasePage import BasePage

class LogoutPage(BasePage):
    def __init__(self, page: Page):
        super().__init__(page)

    def _safe_click(self, locator):
        # Try normal click with scroll
        locator.wait_for(state="attached", timeout=10000)
        locator.scroll_into_view_if_needed(timeout=5000)
        try:
            locator.click(timeout=5000)
            return
        except PlaywrightTimeoutError:
            pass
        except Exception:
            pass

        # Fallback: center scroll via JS and retry
        el = locator.element_handle(timeout=5000)
        if el:
            try:
                self.page.evaluate("el => el.scrollIntoView({block: 'center', inline: 'center'})", el)
                locator.click(timeout=5000)
                return
            except Exception:
                pass

            # Final fallback: direct JS click to bypass viewport/actionability
            try:
                self.page.evaluate("el => el.click()", el)
                return
            except Exception:
                # As a last resort, dispatch a click event
                locator.dispatch_event("click", timeout=5000)

    def logout(self):
        with allure.step("Logout from the application"):
            tools = self.page.get_by_role("link", name="Tools")
            self._safe_click(tools)

            sign_off = self.page.get_by_role("link", name="Sign Off")
            self._safe_click(sign_off)

            self.page.locator("text=Logged out Successfully.").wait_for(state="visible", timeout=10000)
            Results.report_event("User logged out successfully")
            self.attach_screenshot("Logoff Screenshot")

import os
from playwright.sync_api import sync_playwright, expect
from tests.vikings.apps.becca.config.Constants import Constants
from tests.vikings.fw.common.FW import FW
from tests.vikings.fw.common.Results import Results
import re
from dotenv import load_dotenv
load_dotenv(".env.local")

AZURE_USERNAME_INPUT = 'input[name="loginfmt"]'
AZURE_PASSWORD_INPUT = 'input[name="passwd"]'
AZURE_SUBMIT_BUTTON = 'input[type="submit"]'
AZURE_STAY_SIGNED_IN_YES = 'input[value="Yes"]'


def generate_storage_state():
    username = FW.get_env("BECCA_APP_CIRRUS_UI_USERNAME")
    password = FW.get_env("BECCA_APP_CIRRUS_UI_PASSWORD")

    if not username or not password:
        raise RuntimeError("Missing BECCA_APP_CIRRUS_UI_USERNAME or BECCA_APP_CIRRUS_UI_PASSWORD")

    state_path = Constants.BECCA_STORAGE_STATE_PATH
    os.makedirs(os.path.dirname(state_path), exist_ok=True)

    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False, slow_mo=200)
        context = browser.new_context()
        page = context.new_page()

        # Go to app (will redirect to Azure)
        page.goto(Constants.BECCA_URL, wait_until="domcontentloaded")

        # Username
        page.wait_for_selector(AZURE_USERNAME_INPUT, timeout=30000)
        page.fill(AZURE_USERNAME_INPUT, username)
        page.click(AZURE_SUBMIT_BUTTON)

        # Password
        page.wait_for_selector(AZURE_PASSWORD_INPUT, timeout=30000)
        page.fill(AZURE_PASSWORD_INPUT, password)
        page.click(AZURE_SUBMIT_BUTTON)

        # Stay signed in? (optional)
        try:
            page.wait_for_selector(AZURE_STAY_SIGNED_IN_YES, timeout=5000)
            page.click(AZURE_STAY_SIGNED_IN_YES)
        except Exception:
            pass

        # IMPORTANT: Complete MFA manually (OTP/Approve/etc.)
        print("\n✅ Complete MFA in the opened browser window.")
        print("✅ Once BECCA loads, come back and press Resume in the Playwright Inspector.\n")

        # This opens inspector and pauses here so you can finish MFA manually
        page.pause()

        # After you resume, validate you're out of MS login and app is loaded
        page.wait_for_load_state("networkidle", timeout=60000)
        expect(page).not_to_have_url(re.compile(r".*login\.microsoftonline\.com.*"))


# Save state
        context.storage_state(path=state_path)
        Results.report_event(f"Saved storage state to: {state_path}")
        print(f"\n✅ storageState saved at: {state_path}\n")

        context.close()
        browser.close()


if __name__ == "__main__":
    generate_storage_state()


import io
import logging
import os

import allure
import pandas as pd
import pytest
from tests.vikings.apps.becca.config.Constants import Constants
from tests.vikings.fw.common.FW import FW
from tests.vikings.apps.becca.ui_pages.LoginPage import LoginPage
from tests.vikings.fw.common.CommonUtils import CommonUtils

@pytest.fixture(scope="function")
def rows_accumulator(request):
    rows_dict = {}
    yield rows_dict

@pytest.fixture(scope="function", autouse=True)
def generate_result(request,rows_accumulator, tmp_path_factory):
    yield
    COLUMNS_ORDER = getattr(request.node, "COLUMNS_ORDER", [])
    if COLUMNS_ORDER:
        temp_dir = tmp_path_factory.getbasetemp()
        temp_file = temp_dir / f"{FW.get_result_file_name(os.getpid())}"
        logging.info(f"base temp:{temp_dir}")
        logging.info(f"file path:{temp_file}")
        if rows_accumulator:
            df = pd.DataFrame(list(rows_accumulator.values()))
            for col in COLUMNS_ORDER:
                if col not in df.columns:
                    df[col] = ""
            df = df[COLUMNS_ORDER]
            if temp_file.exists():
                df.to_csv(temp_file, mode='a', header=False, index=False)
            else:
                df.to_csv(temp_file, index=False)
    else:
        logging.info("No COLUMNS_ORDER found on the test node.")

@pytest.fixture(scope="function", autouse=True)
def test_summary(request, rows_accumulator):
    yield
    try:
        COLUMNS_ORDER = getattr(request.node, "COLUMNS_ORDER", [])
        if COLUMNS_ORDER :
            if rows_accumulator:
                df = pd.DataFrame(list(rows_accumulator.values()))
                for col in COLUMNS_ORDER:
                    if col not in df.columns:
                        df[col] = ""
                df = df[COLUMNS_ORDER]
                csv_buffer = io.StringIO()
                df.to_csv(csv_buffer, index=False)
                allure.attach(csv_buffer.getvalue(), name="Test summary", attachment_type=allure.attachment_type.CSV)
        else:
            logging.info("No COLUMNS_ORDER found on the test node for summary attachment.")
    except Exception as e:
        logging.info(f"CSV Attach Error: {e}")

@pytest.fixture(scope="session")
def authenticated_context(browser):
    state_path = Constants.BECCA_STORAGE_STATE_PATH

    if not os.path.exists(state_path):
        raise RuntimeError(
            f"Storage state not found at {state_path}. "
            f"Run: python -m tests.vikings.apps.becca.auth.generate_storage_state"
        )

    # Create ONE persistent context for all tests
    context = browser.new_context(storage_state=state_path)

    # Warm up session (ensures Azure login is bypassed)
    page = context.new_page()
    page.goto(Constants.BECCA_URL, wait_until="networkidle")

    yield context
    context.close()

@pytest.fixture()
def becca_page(browser):
    is_local = CommonUtils.is_local_run()
    state_path = Constants.BECCA_STORAGE_STATE_PATH
    if is_local:
        if not os.path.exists(state_path):
            raise RuntimeError(
                f"[LOCAL RUN] Storage state not found at {state_path}.\n"
                "Generate it using:\n"
                "  python -m tests.vikings.apps.becca.auth.generate_storage_state\n"
            )

        logging.info(f"[BECCA AUTH] Local run detected -> using storageState: {state_path}")
        context = browser.new_context(storage_state=state_path)
        page = context.new_page()
        page.goto(Constants.BECCA_URL, wait_until="domcontentloaded")
        yield page
        context.close()

    else:
        logging.info("[BECCA AUTH] Non-local run detected -> using LoginPage.login()")
        context = browser.new_context()
        page = context.new_page()
        login = LoginPage(page)
        login.login()
        yield page
        context.close()


        elif CommonUtils.get_app_name() == CommonConstants.BECCA:
            return """
                    Evaluate ACTUAL_OUTPUT against EXPECTED_OUTPUT for correctness and completeness.
            
                    Scoring guidance:
                    - 1.0 (100%): The answer matches the expected response in meaning and includes all key facts/values.
                    - 0.75 (75%): Mostly correct but missing minor details, slight formatting differences are okay.
                    - 0.5 (50%): Partially correct; includes some relevant info but misses key facts or contains ambiguity.
                    - 0.0 (0%): Incorrect, irrelevant, hallucinated, or contradicts the expected response.
            
                    Rules:
                    - Do not penalize minor wording/format differences if meaning is the same.
                    - Penalize hallucinated facts not supported by EXPECTED_OUTPUT.
                    - If ACTUAL_OUTPUT is empty/"none"/error/refusal, score 0.0.
                    """
