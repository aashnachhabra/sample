package com.optum.eni.core.rules.engine.service.impl;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import com.optum.eni.core.rules.engine.event.*;
import com.optum.eni.core.rules.engine.service.ChildRuleApiService;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.MatchQueryBuilder;
import org.elasticsearch.index.query.Operator;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import com.optum.eni.core.rules.engine.config.stargate.EnvConfigService;
import com.optum.eni.core.rules.engine.coremongodb.domain.ChildRule;
import com.optum.eni.core.rules.engine.coremongodb.repo.ChildRuleRepository;
import com.optum.eni.core.rules.engine.elasticlibrary.entity.ParentAppliesto;
import com.optum.eni.core.rules.engine.elasticlibrary.entity.ParentCocSeries;
import com.optum.eni.core.rules.engine.elasticlibrary.entity.ParentLicense;
import com.optum.eni.core.rules.engine.elasticlibrary.entity.ParentOrganization;
import com.optum.eni.core.rules.engine.elasticlibrary.entity.ParentRule;
import com.optum.eni.core.rules.engine.elasticlibrary.entity.ParentSegment;
import com.optum.eni.core.rules.engine.elasticlibrary.entity.RuleHeaderDetails;
import com.optum.eni.core.rules.engine.model.ChildRuleModel;
import com.optum.eni.core.rules.engine.model.ConditionModel;
import com.optum.eni.core.rules.engine.model.LibrarySearchResult;
import com.optum.eni.core.rules.engine.model.ParentRuleRequest;
import com.optum.eni.core.rules.engine.model.RulesModel;
import com.optum.eni.core.rules.engine.mongodb.domain.ChildValidation;
import com.optum.eni.core.rules.engine.mongodb.domain.FieldValidationMessage;
import com.optum.eni.core.rules.engine.service.CoreConnectorService;

@Component
public class CoreConnectorServiceImpl implements CoreConnectorService {

    private static final Logger logger = LoggerFactory.getLogger(CoreConnectorServiceImpl.class);

    private ObjectMapper mapper = new ObjectMapper();

    private ChildRuleRepository childRuleRepository;

    private static final String NULL_VALUE = "null";

    private static final String BENEFITS = "Benefits";

    private RestHighLevelClient client;

    @Autowired
    ChildRuleApiService childRuleApiService;

    @Value("${ece.index.name}")
    private String eceIndexName;

    @Value("${child.rules.api.url}")
    private String childRulesApiUrl;

    /**
     * Instantiates a new CoreConnector service.
     *
     * @param envConfigService the env config service transformer service
     */
    @Autowired
    public CoreConnectorServiceImpl(RestHighLevelClient client, ChildRuleRepository childRuleRepository) {
        this.client = client;
        this.childRuleRepository = childRuleRepository;
    }

    public CoreConnectorServiceImpl(EnvConfigService envConfigService, RestTemplate restTemplate, ObjectMapper mapper2,
                                    ChildRuleRepository childRuleRepository2) {
        // TODO Auto-generated constructor stub
    }

    @Override
    public List<LibrarySearchResult> fetchParentRules(ParentRuleRequest parentRuleRequest) {

        logger.info("**** Inside fetchParentRules ****");

        return parentRules(parentRuleRequest);
    }

    public List<LibrarySearchResult> parentRules(ParentRuleRequest parentRuleRequest) {

        List<LibrarySearchResult> librarySearchList = new ArrayList<>();

        SearchRequest searchRequest = new SearchRequest();

        searchRequest.indices(eceIndexName);

        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();

        final BoolQueryBuilder finalBoolQuery = new BoolQueryBuilder();

        /**
         * Rupe Type Filter
         */
        BoolQueryBuilder ruleTypeBoolQuery = QueryBuilders.boolQuery();

		/*if (parentRuleRequest.getRuleTypeIn() != null && !parentRuleRequest.getRuleTypeIn().isEmpty()) {

			if (!"0".equals(parentRuleRequest.getRuleTypeIn())) {
				ruleTypeBoolQuery
						.should(QueryBuilders.matchQuery("parentType.parentTypeID", parentRuleRequest.getRuleTypeIn()));
			}
			finalBoolQuery.must(ruleTypeBoolQuery);
		}*/

        MatchQueryBuilder matchNotDeletedQueryBuilder = QueryBuilders.matchQuery("isDeleted", false)
                .operator(Operator.AND);

        finalBoolQuery.must(matchNotDeletedQueryBuilder);

        /**
         * benefitCategory filter
         */

        if (parentRuleRequest.getBenCat() != null && !parentRuleRequest.getBenCat().isEmpty()) {

            BoolQueryBuilder benefitCategoryBoolQuery = QueryBuilders.boolQuery();

            benefitCategoryBoolQuery
                    .should(QueryBuilders.matchQuery("benefitCategory.benCatName", parentRuleRequest.getBenCat()));

            finalBoolQuery.must(benefitCategoryBoolQuery);
        }

        /**
         * plan filter
         */

		/*if (parentRuleRequest.getPlanIn() != null && !parentRuleRequest.getPlanIn().isEmpty()) {

			BoolQueryBuilder planBoolQuery = QueryBuilders.boolQuery();

			planBoolQuery
					.should(QueryBuilders.matchQuery("planType.planTypeName", parentRuleRequest.getPlanIn()));

			finalBoolQuery.must(planBoolQuery);

		}*/

        /**
         * cocSeries Filter
         */

		/*if (parentRuleRequest.getCocseriesIn() != null && !parentRuleRequest.getCocseriesIn().isEmpty()) {

			BoolQueryBuilder cocseriesBoolQuery = QueryBuilders.boolQuery();

			cocseriesBoolQuery.should(
					QueryBuilders.matchQuery("parentCocSeries.cocSeriesName", parentRuleRequest.getCocseriesIn()));

			finalBoolQuery.must(cocseriesBoolQuery);

		}*/

        /**
         * org Filter
         */

        if (parentRuleRequest.getOrgIn() != null && !parentRuleRequest.getOrgIn().isEmpty()) {

            BoolQueryBuilder orgBoolQuery = QueryBuilders.boolQuery();

            orgBoolQuery
                    .should(QueryBuilders.matchQuery("parentOrganization.orgName", parentRuleRequest.getOrgIn()));

            finalBoolQuery.must(orgBoolQuery);

        }

        /**
         * state Filter
         */

        if (parentRuleRequest.getStateIn() != null && !parentRuleRequest.getStateIn().isEmpty()) {
            List<String> statelist = new ArrayList<>();
            statelist.add(parentRuleRequest.getStateIn());
            statelist.add("AS"); //Consider parent rules with All States

            BoolQueryBuilder stateBoolQuery = QueryBuilders.boolQuery();
            for (String state : statelist) {
                stateBoolQuery.should(QueryBuilders.matchQuery("parentState.stateShortName", state));
            }

            finalBoolQuery.must(stateBoolQuery);

        }

        /**
         * segment Filter
         */

        if (parentRuleRequest.getSegmentIn() != null && !parentRuleRequest.getSegmentIn().isEmpty()) {

            BoolQueryBuilder segmentBoolQuery = QueryBuilders.boolQuery();

            segmentBoolQuery.should(
                    QueryBuilders.matchQuery("parentSegmentList.segmentShortName", parentRuleRequest.getSegmentIn()));

            finalBoolQuery.must(segmentBoolQuery);

        }

        /**
         * license Filter
         */

        if (parentRuleRequest.getLicenseIn() != null && !parentRuleRequest.getLicenseIn().isEmpty()) {

            BoolQueryBuilder licenseBoolQuery = QueryBuilders.boolQuery();

            licenseBoolQuery.should(
                    QueryBuilders.matchQuery("parentLicense.licenseShortName", parentRuleRequest.getLicenseIn()));

            finalBoolQuery.must(licenseBoolQuery);

        }

        /**
         * Status Filter
         */

        BoolQueryBuilder statusBoolQuery = QueryBuilders.boolQuery();
        statusBoolQuery.should(QueryBuilders.matchQuery("status", "Published"));
        finalBoolQuery.must(statusBoolQuery);

        searchSourceBuilder.query(finalBoolQuery);

        int start = 0;

        int recordsPerPage = 10;

        searchSourceBuilder.from(start);

        searchSourceBuilder.size(recordsPerPage);

        searchRequest.source(searchSourceBuilder);

        try {

            SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);

            SearchHit[] searchHit = searchResponse.getHits().getHits();

            ObjectMapper mapper = getObjectMapper();

            for (SearchHit hit : searchHit) {

                ParentRule parentRule = mapper.convertValue(hit.getSourceAsMap(), ParentRule.class);

                LibrarySearchResult librarySearchResult = convert(parentRule);

                if (librarySearchResult.getRuleId() != null) {

                    librarySearchList.add(librarySearchResult);
                }

            }

            Long totalRecords = searchResponse.getHits().getTotalHits().value;

            logger.info("Total  Records {} ", totalRecords);

            int count = recordsPerPage;

            while ((long) count < totalRecords) {

                searchSourceBuilder.from(count);

                searchSourceBuilder.size(recordsPerPage);

                searchRequest.source(searchSourceBuilder);

                searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);

                searchHit = searchResponse.getHits().getHits();

                mapper = getObjectMapper();

                for (SearchHit hit : searchHit) {

                    ParentRule parentRule = mapper.convertValue(hit.getSourceAsMap(), ParentRule.class);

                    LibrarySearchResult librarySearchResult = convert(parentRule);

                    if (librarySearchResult.getRuleId() != null) {

                        librarySearchList.add(librarySearchResult);
                    }

                }

                count = count + recordsPerPage;
            }

        } catch (Exception ex) {

            logger.error("Exception while reading the data from elastic search ex {}  ", ex);
        }

        return librarySearchList;

    }

    /**
     * Convert ParentRule to LibrarySearchResult
     *
     * @param parentRule
     * @return
     */
    public LibrarySearchResult convert(ParentRule parentRule) {

        LibrarySearchResult librarySearchResult = new LibrarySearchResult();

        if (parentRule != null && !parentRule.isDeleted()) {

            librarySearchResult.setRuleId(parentRule.getId());
            librarySearchResult.setRuleTitle(parentRule.getRuleTitle());
            librarySearchResult.setRuleDescription(parentRule.getParentDesc());
            librarySearchResult.setRuleDescEffectiveDate(parentRule.getEffectiveDate());
            librarySearchResult.setRuleDescDiscontinueDate(parentRule.getIneffectiveDate());
            librarySearchResult.setStatusCode(parentRule.getStatus());
            if (parentRule.getPlanType() != null) {
                librarySearchResult.setPlanType(parentRule.getPlanType().getPlanTypeName());
            }
            if (parentRule.getBenefitCategory() != null) {
                librarySearchResult.setBenefitCategoryName(parentRule.getBenefitCategory().getBenCatName());
                librarySearchResult.setBenefitCategory(parentRule.getBenefitCategory().getBenCatShortName());
            }

            if (parentRule.getParentRuleState() != null) {
                librarySearchResult.setStateCode(parentRule.getParentRuleState().getStateShortName());
            }

            if (parentRule.getParentType() != null) {
                librarySearchResult.setRuleTypeId(parentRule.getParentType().getParentTypeID());
            }

            /**
             * Add Other details
             */
            mapParentDetails(librarySearchResult, parentRule, false);

        }

        return librarySearchResult;

    }

    private void mapParentDetails(LibrarySearchResult librarySearchResult, ParentRule parentRule, boolean isExport) {

        if (parentRule.getParentCocSeries() != null) {
            Set<String> cocSeriesNames = parentRule.getParentCocSeries().stream().map(ParentCocSeries::getCocSeriesName)
                    .collect(Collectors.toSet());
            librarySearchResult.setCocSeries(mapSetToString(cocSeriesNames));
        }
        if (parentRule.getParentOrganization() != null) {
            Set<String> orgNames = parentRule.getParentOrganization().stream().map(ParentOrganization::getOrgShortName)
                    .collect(Collectors.toSet());
            librarySearchResult.setOrgName(mapSetToString(orgNames));
        }
        if (parentRule.getParentSegmentList() != null) {
            Set<String> segmentNames = parentRule.getParentSegmentList().stream()
                    .map(ParentSegment::getSegmentShortName).collect(Collectors.toSet());
            librarySearchResult.setSegment(mapSetToString(segmentNames));
        }
        if (parentRule.getParentLicense() != null) {
            Set<String> licenseNames = parentRule.getParentLicense().stream().map(ParentLicense::getLicenseShortName)
                    .collect(Collectors.toSet());
            librarySearchResult.setLicense(mapSetToString(licenseNames));
        }
        if (parentRule.getAppliestos() != null && !parentRule.getAppliestos().isEmpty()) {
            Set<String> appliestos = parentRule.getAppliestos().stream().map(ParentAppliesto::getAppliestoName)
                    .collect(Collectors.toSet());
            librarySearchResult.setRuleCategory(mapSetToString(appliestos));
        } else {
            librarySearchResult.setRuleCategory(BENEFITS);
        }

        if (isExport && parentRule.getRuleHeaderDetails() != null) {

            List<String> bodys = parentRule.getRuleHeaderDetails().stream().map(RuleHeaderDetails::getHeaderName)
                    .collect(Collectors.toList());
            librarySearchResult.setBody(bodys);

        } else if (parentRule.getRuleHeaderDetails() != null) {
            List<String> bodys = parentRule.getRuleHeaderDetails().stream().map(RuleHeaderDetails::getBody)
                    .collect(Collectors.toList());
            librarySearchResult.setBody(bodys);
        }

    }

    /**
     * Convert Set to String
     *
     * @param values
     * @return
     */
    private String mapSetToString(Set<String> values) {
        StringBuilder result = new StringBuilder(100);
        boolean append = false;
        if (values == null || values.isEmpty()) {
            result.append(NULL_VALUE);
        } else {
            for (String value : values) {
                if (append) {
                    result.append(", ");
                }
                result.append(value);
                append = true;
            }
        }
        return result.toString();
    }

    @Override
    public List<ChildRuleModel> fetchChildRules(Long parentRuleId) {

        List<ChildRuleModel> childRuleModels = new ArrayList<>();
        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        if (parentRuleId != null) {

            try {

                List<ChildRule> childRules = childRuleApiService.fetchChildRulesFromApi(
                        childRulesApiUrl + "?parentId="+ parentRuleId
                );

                if (!childRules.isEmpty()) {

                    for (ChildRule childRule : childRules) {

                        String rule = mapper.writeValueAsString(childRule);

                        ChildRuleModel childRuleModel = mapper.readValue(rule, ChildRuleModel.class);

                        if (childRuleModel != null) {

                            childRuleModels.add(childRuleModel);

                        }

                    }
                }

            } catch (IOException ioEx) {

                logger.error("Error while parsing the parent rules {} ", ioEx);

            }

        }

        return childRuleModels;
    }

    @Override
    public List<ChildValidation> validate(String payload, List<ChildRuleModel> childRules) {
        List<ChildValidation> childValidationMessages = new ArrayList<>();
        if (!childRules.isEmpty()) {
            for (ChildRuleModel childRuleModel : childRules) {
                String when = childRuleModel.getRuleLogicWhen();
                String then = childRuleModel.getRuleLogicThen();
                try {
                    ConditionModel whenCondition = mapper.readValue(when, ConditionModel.class);
                    ConditionModel thenCondition = mapper.readValue(then, ConditionModel.class);
                    logger.info("When condition : {} ", whenCondition);
                    logger.info("Then condition : {} ", thenCondition);
                    List<FieldValidationMessage> fieldValidationMessages = new ArrayList<>();
                    boolean isValid = validateCondition(payload, thenCondition, fieldValidationMessages);
                    if (isValid) {

                        // Validate When
                        fieldValidationMessages = new ArrayList<>();
                        boolean isValidWhen = validateCondition(payload, whenCondition, fieldValidationMessages);
                        if (isValidWhen) {
                            // Success Status
                            fieldValidationMessages = new ArrayList<>();
                        } else {
                            // Failure Status
							/*if (!fieldValidationMessages.isEmpty()) {
								ChildValidation childValidation = new ChildValidation();
								childValidation.setChildId(childRuleModel.getOriginalChildRuleId());
								childValidation.setFieldValidationMessage(fieldValidationMessages);
								childValidation.setRuleType(childRuleModel.getRuleType());
								childValidation.setRuleDescription(childRuleModel.getRuleDescription());
								childValidationMessages.add(childValidation);
								setValidationMessageForBenifitCategory(payload,childValidation);
							}*/
                        }
                    } else {
                        // Store the status
                        if (!fieldValidationMessages.isEmpty()) {
                            ChildValidation childValidation = new ChildValidation();
                            childValidation.setChildId(childRuleModel.getOriginalChildRuleId());
                            childValidation.setFieldValidationMessage(fieldValidationMessages);
                            childValidation.setRuleType(childRuleModel.getRuleType());
                            childValidation.setRuleDescription(childRuleModel.getRuleDescription());
                            childValidationMessages.add(childValidation);
                            setValidationMessageForBenifitCategory(payload, childValidation);
                        }
                    }
                } catch (IOException ioEx) {
                    logger.error("Error while parsing the parent rules {} ", ioEx);
                }
            }
        }

        return childValidationMessages;
    }

    private void setValidationMessageForBenifitCategory(String payload, ChildValidation childValidation) {

        try {
            List<FieldValidationMessage> fieldValidation = childValidation.getFieldValidationMessage();
            for (FieldValidationMessage fieldValidationMessage : fieldValidation) {
                BulkPlans event = mapper.readValue(payload, BulkPlans.class);

                event.getBenefits().stream().forEach(benefit -> {

                    String benifitCategory = benefit.getBenefitCategory().toString();

                    List<PaymentLine> lines = benefit.getPaymentLines();
                    for (PaymentLine paymentLine : lines) {
                        List<Limit> limits = paymentLine.getLimits();
                        for (Limit limitData : limits) {

                            String tierNumber = limitData.getTierNumber().toString();
                            fieldValidationMessage.setBenefitCategory(benifitCategory);
                            fieldValidationMessage.setTierNumber(tierNumber);
                        }
                    }
                });
            }

        } catch (JsonProcessingException e) {
            // logger the error message
            logger.error("Error while setting benefitCategory or TierNumber{} ", e);
        }

    }

    private boolean validateCondition(String payload, ConditionModel conditionModel,
                                      List<FieldValidationMessage> fieldValidationMessages) {
        List<Boolean> ruleValidationResults = new ArrayList<>();
        String condition = null;
        if (conditionModel != null) {
            condition = conditionModel.getCondition();
            List<RulesModel> conditionRules = conditionModel.getRules();
            for (RulesModel conditionRule : Optional.ofNullable(conditionRules).orElseGet(ArrayList::new)) {
                boolean isValidated;
                List<RulesModel> nestedRules = conditionRule.getRules();
                if (CollectionUtils.isNotEmpty(nestedRules)) {
                    isValidated = this.validateCondition(payload, conditionRule.getCondition(), nestedRules,
                            fieldValidationMessages);
                } else {
                    isValidated = this.validateCondition(payload, condition, Arrays.asList(conditionRule),
                            fieldValidationMessages);
                }
                ruleValidationResults.add(isValidated);
            }
        }

        boolean isValid = false;
        if (StringUtils.isBlank(condition) || "AND".equalsIgnoreCase(condition)) {
            isValid = !ruleValidationResults.contains(false);
        } else if ("OR".equalsIgnoreCase(condition)) {
            isValid = ruleValidationResults.contains(true);
        }
        return isValid;
    }

    private boolean validateCondition(String payload, String condition, List<RulesModel> rules,
                                      List<FieldValidationMessage> fieldValidationMessage) {
        List<String> thenRules = new ArrayList<>();
        if (rules != null) {
            for (RulesModel rulesModel : rules) {
                boolean isValid = false;
                String field = rulesModel.getField()/* .replaceAll("\\s", "") */;
                String jsonpathCreatorLocationPath = "$.." + field;
                String fieldValue = (String) rulesModel.getValue();
                DocumentContext jsonContext = JsonPath.parse(payload);
                List<String> jsonpathCreatorLocations = jsonContext.read(jsonpathCreatorLocationPath);
                for (Object jsonpathCreatorLocation : jsonpathCreatorLocations) {
                    if (String.valueOf(jsonpathCreatorLocation).equalsIgnoreCase(fieldValue)) {
                        isValid = true;
                        break;
                    }
                }
                thenRules.add(String.valueOf(isValid));
                if (!isValid) {
                    FieldValidationMessage message = new FieldValidationMessage();
                    message.setFieldName(rulesModel.getField());
                    message.setMessage((String) rulesModel.getValue());
                    fieldValidationMessage.add(message);
                }
            }
        }
        boolean isValid = false;
        if (StringUtils.isBlank(condition) || "AND".equalsIgnoreCase(condition)) {
            isValid = !thenRules.contains("false");
        } else if ("OR".equalsIgnoreCase(condition)) {
            isValid = thenRules.contains("true");
        }

        return isValid;
    }

    public ObjectMapper getObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);
        return mapper;
    }

    /************************************************************New validation Logic **********************************************/

    @Override
    public List<ChildValidation> newValidate(String payload, List<ChildRuleModel> childRules) {
        List<ChildValidation> childValidationMessages = new ArrayList<>();
        if (!childRules.isEmpty()) {
            for (ChildRuleModel childRuleModel : childRules) {
                String when = childRuleModel.getRuleLogicWhen();
                String then = childRuleModel.getRuleLogicThen();
                try {
                    ConditionModel whenCondition = mapper.readValue(when, ConditionModel.class);
                    ConditionModel thenCondition = mapper.readValue(then, ConditionModel.class);
                    logger.info("When condition : {} ", whenCondition);
                    logger.info("Then condition : {} ", thenCondition);
                    List<FieldValidationMessage> fieldValidationMessages = new ArrayList<>();
                    // Validate When
                    boolean isValid = validateWhenCondition(payload, whenCondition, fieldValidationMessages);
                    if (isValid) {
                        // Validate Then
                        fieldValidationMessages = new ArrayList<>();
                        boolean isValidThen = validateThenCondition(payload, thenCondition, fieldValidationMessages,
                                whenCondition);
                        if (!isValidThen) {
                            // Failure Status
                            if (!fieldValidationMessages.isEmpty()) {
                                ChildValidation childValidation = new ChildValidation();
                                childValidation.setChildId(childRuleModel.getOriginalChildRuleId());
                                childValidation.setFieldValidationMessage(fieldValidationMessages);
                                childValidation.setRuleType(childRuleModel.getRuleType());
                                childValidation.setRuleDescription(childRuleModel.getRuleDescription());
                                childValidationMessages.add(childValidation);

                                logger.info("Then condition failed!");
                                logger.info("Field Validation Messages: {}", fieldValidationMessages);
                            }
                        }
                    } else {
                        logger.info("When condition failed!");
                        logger.info("Field Validation Messages: {}", fieldValidationMessages);
                    }
                } catch (IOException ioEx) {
                    logger.error("Error while parsing the parent rules {} ", ioEx);
                }
            }
        }
        return childValidationMessages;
    }

    private PaymentLine paymentLineEntry;
    private BenefitTier benefitTier;
    private Limit limit;
    private PlanDetails plan;
    private Benefits benefit;
    private Accumulator accumulator;
    private PharmacyDetails pharmacy;
    private String tierValue;
    private String levelValue;

    private boolean validateWhenCondition(String payload, ConditionModel whenCondition,
                                          List<FieldValidationMessage> fieldValidationMessages) {
        List<Boolean> ruleValidationResults = new ArrayList<>();
        String condition = null;

        //Reset values for global variables
        tierValue = null;
        benefitTier = null;
        limit = null;
        benefit = null;
        paymentLineEntry = null;
        levelValue = null;

        if (whenCondition != null) {
            condition = whenCondition.getCondition();
            List<RulesModel> rulesList = whenCondition.getRules();
            for (RulesModel rule : Optional.ofNullable(rulesList).orElseGet(ArrayList::new)) {
                boolean isValidated;
                List<RulesModel> rulesNextLevel = rule.getRules();
                if (CollectionUtils.isNotEmpty(rulesNextLevel)) {
                    isValidated = this.validateRulesWhen(payload, rule.getCondition(), rulesNextLevel,
                            fieldValidationMessages);
                } else {
                    isValidated = this.validateRulesWhen(payload, condition, Arrays.asList(rule),
                            fieldValidationMessages);
                }
                ruleValidationResults.add(isValidated);
            }
        }

        boolean isValid = false;
        if (StringUtils.isBlank(condition) || "AND".equalsIgnoreCase(condition)) {
            isValid = !ruleValidationResults.contains(false);
        } else if ("OR".equalsIgnoreCase(condition)) {
            isValid = ruleValidationResults.contains(true);
        }
        return isValid;
    }

    private boolean validateRulesWhen(String payload, String condition, List<RulesModel> rules,
                                      List<FieldValidationMessage> fieldValidationMessage) {
        List<String> whenRules = new ArrayList<>();
        Map<CharSequence, Benefits> benefitMap;
        try {
            BulkPlans event = mapper.readValue(payload, BulkPlans.class);
            plan = event.getPlanDetails().get(0);
            accumulator = event.getAccumulators();
            pharmacy = event.getPharmacyDetails();

            System.out.println("Rules :" + rules.size());
            if (rules != null) {
                for (int i = 0; i < rules.size(); i++) {
                    boolean isValid = false;
                    String field = rules.get(i).getField()/* .replaceAll("\\s", "") */;
                    String jsonpathCreatorLocationPath = "$.." + field;
                    String operator = rules.get(i).getOperator();
                    String fieldValue = (String) rules.get(i).getValue();
                    DocumentContext jsonContext = JsonPath.parse(payload);
                    List<String> jsonpathCreatorLocations = jsonContext.read(jsonpathCreatorLocationPath);
                    if (jsonpathCreatorLocations.size() == 1) {
                        // Just 1 key found
                        switch (operator) {
                            case ("is equal to"):
                                if (String.valueOf(jsonpathCreatorLocations.get(0)).equalsIgnoreCase(fieldValue)) {
                                    isValid = true;
                                }
                                break;
                            case ("is not equal to"):
                                if (!String.valueOf(jsonpathCreatorLocations.get(0)).equalsIgnoreCase(fieldValue)) {
                                    isValid = true;
                                }
                                break;
                            case ("contains"):
                                if (String.valueOf(jsonpathCreatorLocations.get(0)).contains(fieldValue)) {
                                    isValid = true;
                                }
                                break;
                            case ("does not contain"):
                                if (!String.valueOf(jsonpathCreatorLocations.get(0)).contains(fieldValue)) {
                                    isValid = true;
                                }
                                break;
                            case ("is less than"):
                                if (Integer.valueOf(String.valueOf(jsonpathCreatorLocations.get(0))) < Integer.valueOf(fieldValue)) {
                                    isValid = true;
                                }
                                break;
                            case ("is less than or equal to"):
                                if (Integer.valueOf(String.valueOf(jsonpathCreatorLocations.get(0))) <= Integer.valueOf(fieldValue)) {
                                    isValid = true;
                                }
                                break;
                            case ("is greater than"):
                                if (Integer.valueOf(String.valueOf(jsonpathCreatorLocations.get(0))) > Integer.valueOf(fieldValue)) {
                                    isValid = true;
                                }
                                break;
                            case ("is greater than or equal to"):
                                if (Integer.valueOf(String.valueOf(jsonpathCreatorLocations.get(0))) >= Integer.valueOf(fieldValue)) {
                                    isValid = true;
                                }
                                break;
                            case ("begins with"):
                                if (String.valueOf(jsonpathCreatorLocations.get(0).toLowerCase()).startsWith(fieldValue.toLowerCase())) {
                                    isValid = true;
                                }
                                break;
                            case ("does not begin with"):
                                if (!String.valueOf(jsonpathCreatorLocations.get(0).toLowerCase()).startsWith(fieldValue.toLowerCase())) {
                                    isValid = true;
                                }
                                break;
                            case ("ends with"):
                                if (String.valueOf(jsonpathCreatorLocations.get(0).toLowerCase()).endsWith(fieldValue.toLowerCase())) {
                                    isValid = true;
                                }
                                break;
                            case ("does not end with"):
                                if (!String.valueOf(jsonpathCreatorLocations.get(0).toLowerCase()).endsWith(fieldValue.toLowerCase())) {
                                    isValid = true;
                                }
                                break;
                            case ("is blank"):
                                if (String.valueOf(jsonpathCreatorLocations.get(0)).isEmpty()) {
                                    isValid = true;
                                }
                                break;
                        }
                        whenRules.add(String.valueOf(isValid));
                        if (!isValid) {
                            FieldValidationMessage message = new FieldValidationMessage();
                            message.setFieldName(rules.get(i).getField());
                            message.setMessage((String) rules.get(i).getValue());
                            fieldValidationMessage.add(message);
                        }
                    } else if (jsonpathCreatorLocations.size() > 1) {
                        if (field.equals("benefitCategory")) {
                            benefitMap = event.getBenefits().stream().collect(Collectors.toMap(Benefits::getBenefitCategory, Function.identity(), (existing, replacement) -> replacement));

                            if (benefitMap.get(rules.get(i).getValue().toString()) != null) {
                                benefit = benefitMap.get(rules.get(i).getValue().toString());
                                whenRules.add("true");
                            } else {
                                whenRules.add("false");
                            }

                        } else {
                            if (benefit != null) {
                                whenRules.add(String.valueOf(benefitCategoryValidator(rules.get(i), benefit)));
                            } else {
                                whenRules.add("false");
                            }
                        }
                    }
                }
            }
        } catch (JsonProcessingException e) {
            logger.error("Error while parsing validateWhenCondition ", e);
        }
        boolean isValid = false;
        if (StringUtils.isBlank(condition) || "AND".equalsIgnoreCase(condition)) {
            isValid = !whenRules.contains("false");
        } else if ("OR".equalsIgnoreCase(condition)) {
            isValid = whenRules.contains("true");
        }
        return isValid;
    }

    private boolean benefitCategoryValidator(RulesModel rule, Benefits benefitEntry) {
        if (rule == null || benefitEntry == null)
            return false;
        boolean isValid = false;
        String condition = rule.getCondition();
        List<Boolean> flags = new ArrayList<>();

        if (rule.getField().equals("tier")) {
            tierValue = rule.getValue().toString();
            flags.add(true);

        } else if (rule.getField().equals("levelvalue")) {
            levelValue = rule.getValue().toString();
            for (PaymentLine paymentLine : benefitEntry.getPaymentLines()) {
                if (paymentLine.getPaymentLineValue().equals(String.valueOf(rule.getValue()))) {
                    flags.add(true);
                    paymentLineEntry = paymentLine;
                } else {
                    flags.add(false);
                }
            }
        } else if (rule.getField().equals("limit")){
            if (tierValue != null) {
                limit = paymentLineEntry.getLimits().stream().filter(limit1 ->
                        limit1.getTierNumber().equals(tierValue)).findAny().orElse(null);
            }
            flags.add(limit != null);
        }


        if (StringUtils.isBlank(condition) || "AND".equalsIgnoreCase(condition)) {
            isValid = !flags.contains(false);
        } else if ("OR".equalsIgnoreCase(condition)) {
            isValid = flags.contains(true);
        }
        return isValid;
    }

    private boolean validateThenCondition(String payload, ConditionModel thenCondition,
                                          List<FieldValidationMessage> fieldValidationMessages, ConditionModel whenCondition) {
        List<Boolean> ruleValidationResults = new ArrayList<>();
        String condition = null;
        if (thenCondition != null) {
            condition = thenCondition.getCondition();
            List<RulesModel> conditionRules = thenCondition.getRules();
            for (RulesModel conditionRule : Optional.ofNullable(conditionRules).orElseGet(ArrayList::new)) {
                boolean isValidated;
                List<RulesModel> nestedRules = conditionRule.getRules();
                if (CollectionUtils.isNotEmpty(nestedRules)) {
                    isValidated = this.validateRulesThen(payload, conditionRule.getCondition(), nestedRules,
                            fieldValidationMessages);
                } else {
                    isValidated = this.validateRulesThen(payload, condition, Arrays.asList(conditionRule),
                            fieldValidationMessages);
                }
                ruleValidationResults.add(isValidated);
            }
        }

        boolean isValid = false;
        if (StringUtils.isBlank(condition) || "AND".equalsIgnoreCase(condition)) {
            isValid = !ruleValidationResults.contains(false);
        } else if ("OR".equalsIgnoreCase(condition)) {
            isValid = ruleValidationResults.contains(true);
        }
        return isValid;
    }

    private boolean validateRulesThen(String payload, String condition, List<RulesModel> rules,
                                      List<FieldValidationMessage> fieldValidationMessage) {
        List<String> thenResults = new ArrayList<>();
        try {
            System.out.println("Rules :" + rules.size());
            if (rules != null) {
                for (int i = 0; i < rules.size(); i++) {
                    boolean isValid = false;
                    boolean isPrelimValid = true;
                    String msg = null;
                    String errorMsg = "Validations cannot proceed due to missing rule criterion: ";
                    String planValueLmt = null;
                    String planValueBt = null;
                    String planValueDetail = null;
                    String planValueAccumulator = null;
                    String planValuePharmacy = null;
                    String field = rules.get(i).getField()/* .replaceAll("\\s", "") */;
                    Object value = rules.get(i).getValue();
                    String operator = rules.get(i).getOperator();

                    if (benefit != null) {
                        if (paymentLineEntry == null) {
                            if (benefit.getPaymentLines().size() > 1) {
                                if (levelValue != null) {
                                    paymentLineEntry = benefit.getPaymentLines().stream().filter(paymentLine ->
                                            paymentLine.getPaymentLineValue().equals(levelValue)).findAny().orElse(null);
                                }
                            } else {
                                for (PaymentLine paymentLine : benefit.getPaymentLines()) {
                                    paymentLineEntry = paymentLine;
                                }
                            }
                        }

                        if (tierValue != null) {
                            benefitTier = paymentLineEntry.getBenefitTiers().stream().filter(benefitTier1 ->
                                    benefitTier1.getTierNumber().equals(tierValue)).findAny().orElse(null);

                            if (limit == null) {
                                limit = paymentLineEntry.getLimits().stream().filter(limit1 ->
                                        limit1.getTierNumber().equals(String.valueOf(tierValue))).findAny().orElse(null);
                            }
                        }
                    }

                    //Get the value of the field to be validated
                    if (limit != null) {
                        planValueLmt = getMethodForLMT(field) == null ? null : getMethodForLMT(field).invoke(limit).toString();
                    }
                    if (benefitTier != null) {
                        if (getMethodForBT(field) != null) {
                            planValueBt = getMethodForBT(field).invoke(benefitTier) == null ? "" : getMethodForBT(field).invoke(benefitTier).toString();
                        } else {
                            planValueBt = null;
                        }
                    }
                    if (plan != null  && getMethodForPlan(field) != null) {
                        if (getMethodForPlan(field).invoke(plan) != null) {
                            planValueDetail = getMethodForPlan(field) == null ? null : getMethodForPlan(field).invoke(plan).toString();
                        } else {
                            planValueDetail = "";
                        }
                    }

                    if (accumulator  != null && getMethodForAccumulator(field) != null) {
                        if (getMethodForAccumulator(field).invoke(accumulator) != null) {
                            planValueAccumulator = getMethodForAccumulator(field) == null ? null : getMethodForAccumulator(field).invoke(accumulator).toString();
                        } else {
                            planValueAccumulator = "";
                        }
                    }

                    if (pharmacy  != null && getMethodForPharmacy(field) != null) {
                        if (getMethodForPharmacy(field).invoke(pharmacy) != null) {
                            planValuePharmacy = getMethodForPharmacy(field) == null ? null : getMethodForPharmacy(field).invoke(pharmacy).toString();
                        } else {
                            planValuePharmacy = "";
                        }
                    }

                    //Store the field value
                    if (planValueLmt != null) {
                        msg = planValueLmt.toString();
                    } else if (planValueBt != null) {
                        msg = planValueBt.toString();
                    } else if (planValueDetail != null) {
                        msg = planValueDetail.toString();
                    } else if (planValueAccumulator != null) {
                        msg = planValueAccumulator.toString();
                    } else if (planValuePharmacy != null) {
                        msg = planValuePharmacy.toString();
                    }

                    if (msg == null) {
                        msg = "(Missing)";
                        if (paymentLineEntry == null) {
                            errorMsg = errorMsg + "Payment Line Entry";

                        } else if (tierValue == null){
                            errorMsg = errorMsg + "Benefit Tier";
                        }

                        isPrelimValid = false;
                    }

                    if (isPrelimValid) {
                        switch (operator) {
                            case ("must equal"):
                                if (planValueLmt != null || planValueBt != null) {
                                    if (planValueLmt != null) {
                                        isValid = planValueLmt.equalsIgnoreCase(value.toString());
                                    }
                                    if (planValueBt != null) {
                                        isValid = planValueBt.equalsIgnoreCase(value.toString());
                                    }
                                } else if (planValueDetail != null) {
                                    isValid = planValueDetail.equalsIgnoreCase(value.toString());
                                } else if (planValueAccumulator != null) {
                                    isValid = planValueAccumulator.equalsIgnoreCase(value.toString());
                                } else if (planValuePharmacy != null) {
                                    isValid = planValuePharmacy.equalsIgnoreCase(value.toString());
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must not equal"):
                                if (planValueLmt != null || planValueBt != null) {
                                    if (planValueLmt != null) {
                                        isValid = !planValueLmt.equalsIgnoreCase(value.toString());
                                    }
                                    if (planValueBt != null) {
                                        isValid = !planValueBt.equalsIgnoreCase(value.toString());
                                    }
                                } else if (planValueDetail != null) {
                                    isValid = !planValueDetail.equalsIgnoreCase(value.toString());
                                } else if (planValueAccumulator != null) {
                                    isValid = !planValueAccumulator.equalsIgnoreCase(value.toString());
                                } else if (planValuePharmacy != null) {
                                    isValid = !planValuePharmacy.equalsIgnoreCase(value.toString());
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must be present"):
                            case ("must not be blank"):
                                if (planValueLmt != null && !planValueLmt.trim().isEmpty()) {
                                    isValid = true;
                                } else if (planValueBt != null && !planValueBt.trim().isEmpty()) {
                                    isValid = true;
                                } else if (planValueDetail != null && !planValueDetail.trim().isEmpty()) {
                                    isValid = true;
                                } else if (planValueAccumulator != null && !planValueAccumulator.trim().isEmpty()) {
                                    isValid = true;
                                } else if (planValuePharmacy != null && !planValuePharmacy.trim().isEmpty()) {
                                    isValid = true;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must not be present"):
                            case ("must be blank"):
                                if (planValueLmt != null && planValueLmt.trim().isEmpty()) {
                                    isValid = true;
                                } else if (planValueBt != null && planValueBt.trim().isEmpty()) {
                                    isValid = true;
                                } else if (planValueDetail != null && planValueDetail.isEmpty()) {
                                    isValid = true;
                                } else if (planValueAccumulator != null && planValueAccumulator.isEmpty()) {
                                    isValid = true;
                                } else if (planValuePharmacy != null && planValuePharmacy.isEmpty()) {
                                    isValid = true;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must be between"):
                                List<CharSequence> values = (List<CharSequence>) value;
                                int lowerBound = Integer.valueOf((String) values.get(0));
                                int upperBound = Integer.valueOf((String) values.get(1));
                                Integer planValue = null;

                                if (planValueLmt != null || planValueBt != null) {
                                    if (planValueLmt != null) {
                                        planValue = Integer.valueOf((planValueLmt));
                                    }
                                    if (planValueBt != null) {
                                        planValue = Integer.valueOf(planValueBt);
                                    }
                                } else if (planValueDetail != null) {
                                    planValue = Integer.valueOf((planValueDetail));
                                } else if (planValueAccumulator != null) {
                                    planValue = Integer.valueOf((planValueAccumulator));
                                } else if (planValuePharmacy != null) {
                                    planValue = Integer.valueOf((planValuePharmacy));
                                }

                                if (planValue != null && (lowerBound <= planValue && planValue <= upperBound)) {
                                    isValid = true;
                                    thenResults.add("true");
                                } else {
                                    isValid = false;
                                    thenResults.add("false");
                                }
                                break;
                            case ("must be less than"):
                                if (value != null && !value.toString().isEmpty() && !value.toString().equalsIgnoreCase("n/a")) {
                                    if (planValueLmt != null && !planValueLmt.isEmpty() && !planValueLmt.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueLmt) < convertStringToInteger(value.toString());
                                    } else if (planValueBt != null && !planValueBt.isEmpty() && !planValueBt.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueBt) < convertStringToInteger(value.toString());
                                    } else if (planValueDetail != null && !planValueDetail.isEmpty() && !planValueDetail.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueDetail) < convertStringToInteger(value.toString());
                                    } else if (planValueAccumulator != null && !planValueAccumulator.isEmpty() && !planValueAccumulator.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueAccumulator) < convertStringToInteger(value.toString());
                                    } else if (planValuePharmacy != null && !planValuePharmacy.isEmpty() && !planValuePharmacy.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValuePharmacy) < convertStringToInteger(value.toString());
                                    }
                                } else {
                                    isValid = false;
                                }

                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must be less than or equal to"):
                                if (value != null && !value.toString().isEmpty() && !value.toString().equalsIgnoreCase("n/a")) {
                                    if (planValueLmt != null && !planValueLmt.isEmpty() && !planValueLmt.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueLmt) <= convertStringToInteger(value.toString());
                                    } else if (planValueBt != null && !planValueBt.isEmpty() && !planValueBt.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueBt) <= convertStringToInteger(value.toString());
                                    } else if (planValueDetail != null && !planValueDetail.isEmpty() && !planValueDetail.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueDetail) <= convertStringToInteger(value.toString());
                                    } else if (planValueAccumulator != null && !planValueAccumulator.isEmpty() && !planValueAccumulator.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueAccumulator) <= convertStringToInteger(value.toString());
                                    } else if (planValuePharmacy != null && !planValuePharmacy.isEmpty() && !planValuePharmacy.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValuePharmacy) <= convertStringToInteger(value.toString());
                                    }
                                } else {
                                    isValid = false;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must be greater than"):
                                if (value != null && !value.toString().isEmpty() && !value.toString().equalsIgnoreCase("n/a")) {
                                    if (planValueLmt != null && !planValueLmt.isEmpty() && !planValueLmt.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueLmt) > convertStringToInteger(value.toString());
                                    } else if (planValueBt != null && !planValueBt.isEmpty() && !planValueBt.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueBt) > convertStringToInteger(value.toString());
                                    } else if (planValueDetail != null && !planValueDetail.isEmpty() && !planValueDetail.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueDetail) > convertStringToInteger(value.toString());
                                    } else if (planValueAccumulator != null && !planValueAccumulator.isEmpty() && !planValueAccumulator.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueAccumulator) > convertStringToInteger(value.toString());
                                    } else if (planValuePharmacy != null && !planValuePharmacy.isEmpty() && !planValuePharmacy.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValuePharmacy) > convertStringToInteger(value.toString());
                                    }
                                } else {
                                    isValid = false;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must be greater than or equal to"):
                                if (value != null && !value.toString().isEmpty() && !value.toString().equalsIgnoreCase("n/a")) {
                                    if (planValueLmt != null && !planValueLmt.isEmpty() && !planValueLmt.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueLmt) >= convertStringToInteger(value.toString());
                                    } else if (planValueBt != null && !planValueBt.isEmpty() && !planValueBt.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueBt) >= convertStringToInteger(value.toString());
                                    } else if (planValueDetail != null && !planValueDetail.isEmpty() && !planValueDetail.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueDetail) >= convertStringToInteger(value.toString());
                                    } else if (planValueAccumulator != null && !planValueAccumulator.isEmpty() && !planValueAccumulator.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValueAccumulator) >= convertStringToInteger(value.toString());
                                    } else if (planValuePharmacy != null && !planValuePharmacy.isEmpty() && !planValuePharmacy.equalsIgnoreCase("n/a")) {
                                        isValid = convertStringToInteger(planValuePharmacy) >= convertStringToInteger(value.toString());
                                    }
                                } else {
                                    isValid = false;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must begin with"):
                                if (planValueLmt != null && planValueLmt.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueBt != null && planValueBt.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueDetail != null && planValueDetail.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueAccumulator != null && planValueAccumulator.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValuePharmacy != null && planValuePharmacy.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must not begin with"):
                                if (planValueLmt != null && !planValueLmt.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueBt != null && !planValueBt.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueDetail != null && !planValueDetail.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueAccumulator != null && !planValueAccumulator.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValuePharmacy != null && !planValuePharmacy.toLowerCase().startsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must end with"):
                                if (planValueLmt != null && planValueLmt.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueBt != null && planValueBt.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueDetail != null && planValueDetail.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueAccumulator != null && planValueAccumulator.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValuePharmacy != null && planValuePharmacy.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must not end with"):
                                if (planValueLmt != null && !planValueLmt.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueBt != null && !planValueBt.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueDetail != null && !planValueDetail.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueAccumulator != null && !planValueAccumulator.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValuePharmacy != null && !planValuePharmacy.toLowerCase().endsWith(value.toString().toLowerCase())) {
                                    isValid = true;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("contains"):
                                if (planValueLmt != null && planValueLmt.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueBt != null && planValueBt.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueDetail != null && planValueDetail.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueAccumulator != null && planValueAccumulator.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValuePharmacy != null && planValuePharmacy.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                            case ("must not contain"):
                                if (planValueLmt != null && !planValueLmt.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueBt != null && !planValueBt.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueDetail != null && !planValueDetail.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValueAccumulator != null && !planValueAccumulator.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                } else if (planValuePharmacy != null && !planValuePharmacy.toLowerCase().contains(value.toString().toLowerCase())) {
                                    isValid = true;
                                }
                                thenResults.add(String.valueOf(isValid));
                                break;
                        }
                    } else {
                        thenResults.add("false");
                    }

                    if (msg.isEmpty()){
                        msg = "(blank)";
                    }

                    if (!isValid) {
                        logger.info("Benefit: {}", benefit);
                        FieldValidationMessage message = new FieldValidationMessage();
                        message.setFieldName(rules.get(i).getField());
                        message.setMessage(msg);
                        message.setErrorMessage(!isPrelimValid ? errorMsg : null);
                        if (benefit != null)
                            message.setBenefitCategory(benefit.getBenefitCategory().toString());

                        if (benefitTier != null)
                            message.setTierNumber(benefitTier.getTierNumber().toString());

                        if (paymentLineEntry != null)
                            message.setPaymentLineValue(paymentLineEntry.getPaymentLineValue().toString());
                        fieldValidationMessage.add(message);
                    }
                }
            }
        } catch (IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
            logger.error("Error while parsing the validateThenCondition {} ", e);
        }

        boolean isValid = false;
        if (StringUtils.isBlank(condition) || "AND".equalsIgnoreCase(condition)) {
            isValid = !thenResults.contains("false");
        } else if ("OR".equalsIgnoreCase(condition)) {
            isValid = thenResults.contains("true");
        }
        return isValid;
    }

    private int convertStringToInteger(String value) {
        return (int) Double.parseDouble(value.replaceAll("[%$]",""));
    }

    private Method getMethodForLMT(String partOfName) {
        final Optional<Method> matchedMethod = Arrays.stream(Limit.class.getDeclaredMethods()).filter(method ->
                method.getName().toLowerCase().equals("get" + partOfName.toLowerCase())).findAny();
        if (!matchedMethod.isPresent()) {
            return null;
        }
        return matchedMethod.get();
    }

    private Method getMethodForBT(String partOfName) {
        final Optional<Method> matchedMethod = Arrays.stream(BenefitTier.class.getDeclaredMethods()).filter(method ->
                method.getName().toLowerCase().equals("get" + partOfName.toLowerCase())).findAny();
        if (!matchedMethod.isPresent()) {
            return null;
        }
        return matchedMethod.get();
    }

    private Method getMethodForPlan(String partOfName) {
        final Optional<Method> matchedMethod = Arrays.stream(PlanDetails.class.getDeclaredMethods()).filter(method ->
                method.getName().toLowerCase().equals("get" + partOfName.toLowerCase())).findAny();
        if (!matchedMethod.isPresent()) {
            return null;
        }
        return matchedMethod.get();
    }

    private Method getMethodForAccumulator(String partOfName) {
        final Optional<Method> matchedMethod = Arrays.stream(Accumulator.class.getDeclaredMethods()).filter(method ->
                method.getName().toLowerCase().equals("get" + partOfName.toLowerCase())).findAny();
        if (!matchedMethod.isPresent()) {
            return null;
        }
        return matchedMethod.get();
    }

    private Method getMethodForPharmacy(String partOfName) {
        final Optional<Method> matchedMethod = Arrays.stream(PharmacyDetails.class.getDeclaredMethods()).filter(method ->
                method.getName().toLowerCase().equals("get" + partOfName.toLowerCase())).findAny();
        if (!matchedMethod.isPresent()) {
            return null;
        }
        return matchedMethod.get();
    }

}
getting error in all imports import org.elasticsearch.action and import org.elasticsearch.index after the pom changes
