public String processQuery(String query) {
        ExecutorService executorService = Executors.newFixedThreadPool(valueConfig.getPoolSize());
        List<Future<String>> futures = new ArrayList<>();
        /** TRANSFORMING QUERY */
        if (valueConfig.getQueryTransformation().equals(Boolean.TRUE)) {
            query = queryTransformationService.transformQuery(query);
        }
        final String finalQuery = query;
        /** FETCHING QUERY CONTEXT FROM VECTOR DB */
        List<String> relatedDocumentation = documentService.getClosestDocumentsAccordingToQuery(finalQuery);
        /** PROCESSING IN PARALLEL */
        int batchSize = valueConfig.getBatchSize();
        for (int i = 0; i < relatedDocumentation.size(); i += batchSize) {
            List<String> batch = relatedDocumentation.subList(i, Math.min(i + batchSize, relatedDocumentation.size()));
            System.out.println("Processing Batch: " + batch);
            Callable<String> task = () -> {
                /** Generate context for the current batch */
                String contextBasedOnquery = getRelatedDocumentationBasedOnTokenLimit(batch);
                System.out.println("Context for batch: " + contextBasedOnquery);
                /** Prepare requestMsg within the lambda */
                List<Message> requestMsg = new ArrayList<>();
                requestMsg.add(Message.builder().role(Constants.USER).content(finalQuery).build());
                if (!CollectionUtils.isEmpty(batch)) {
                    requestMsg.add(Message.builder().role(Constants.ASSISTANT).content(contextBasedOnquery).build());
                }
                /** Create ChatGPTRequest */
                ChatGPTRequest chatGPTRequest = ChatGPTRequest.builder()
                        .messages(requestMsg)
                        .build();
                /** Process request and return response */
                Message chatResponse = chatBotAssistant.processRequest(chatGPTRequest);
                System.out.println("Response for batch: " + chatResponse);
                return chatResponse.getContent();
            };
            /** Submit task to ExecutorService */
            futures.add(executorService.submit(task));
        }
        /** COLLECTING INTERMEDIATE RESPONSES */
        List<String> intermediateResponses = new ArrayList<>();
        for (Future<String> future : futures) {
            try {
                intermediateResponses.add(future.get()); // Blocks until task completes
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
        /** FINAL PROCESSING OF INTERMEDIATE RESPONSES */
        executorService.shutdown();
        String finalContext = String.join("\n", intermediateResponses);
        System.out.println("Final synthesized context: " + finalContext);
        /** Create final request message */
        List<Message> finalRequestMsg = new ArrayList<>();
        finalRequestMsg.add(Message.builder().role(Constants.USER).content(finalQuery).build());
        finalRequestMsg.add(Message.builder().role(Constants.ASSISTANT).content(finalContext).build());
        finalRequestMsg.add(Message.builder().role(Constants.SYSTEM).content(Prompts.COMBINING_PROMPT).build());
        ChatGPTRequest finalChatGPTRequest = ChatGPTRequest.builder()
                .messages(finalRequestMsg)
                .build();
        /** GETTING FINAL RESPONSE AND STORING RESPONSE IN SESSION */
        Message finalChatResponse = chatBotAssistant.processRequest(finalChatGPTRequest);
        System.out.println("Final response: " + finalChatResponse.getContent());
        return finalChatResponse.getContent();
    }
so basically i want to modify this code. for example if theres too many files say 12 and finally i have 6 docs if batchsize is 2 so String finalContext = String.join("\n", intermediateResponses);
this piece of string would be very long and there is a token limit so a lot of fruitful data might not be processed. So now what i want to do is keep doing the multi threading on these intermediate responses also so that at the end only one response is left and i return it to make this code more scalable for more files
For ref relatedDocumentation is list of string of codes from the files and intermediate responses are responses from chatgpt based on the processing of those files in batch size of 2
only create a recursive call for intermediate responses for eg intermediate responses =[res1, res2, res3] i want to send res 1 and res 2 to chatgpt for processing and get a response say res 4. Now i want to process res 4 and res 3 and get a final response and return that response. You might wanna handle cases for even and odd number of responses
do not disturb the code before         executorService.shutdown(); and only do recursive for intermediate responses
